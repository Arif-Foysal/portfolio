---
title: "Performance Optimization"
description: "Techniques and best practices to optimize React Native app performance"
navigation:
  icon: i-lucide-house
---

# Performance Optimization

#react-native #performance #optimization #stage-5

> Techniques and best practices to optimize React Native app performance

## 🔗 Navigation
← [[13.Popular React Native Libraries]] | → [[15.Advanced Animations]]

---

## JavaScript Thread vs UI Thread

Understanding React Native's thread architecture is crucial for optimization.

### Thread Architecture
```jsx path=null start=null
// JavaScript Thread - handles business logic, API calls, state updates
const fetchUserData = async () => {
  const response = await fetch('https://api.example.com/user');
  const userData = await response.json();
  setUser(userData); // State update happens on JS thread
};

// UI Thread (Main Thread) - handles native UI rendering and user interactions
// Heavy JavaScript operations can block this thread
```

### Thread Monitoring
```jsx path=null start=null
// Enable performance monitoring in development
import { enableScreens } from 'react-native-screens';

// Performance logs in development
if (__DEV__) {
  const originalLog = console.log;
  console.log = (...args) => {
    const timestamp = new Date().toISOString();
    originalLog(`[${timestamp}]`, ...args);
  };
}

enableScreens();
```

---

## Component Optimization

Optimize React components to prevent unnecessary re-renders.

### React.memo and useMemo
```jsx path=null start=null
import React, { memo, useMemo, useCallback } from 'react';

// Memoize expensive components
const ExpensiveListItem = memo(({ item, onPress }) => {
  console.log('Rendering item:', item.id);
  
  return (
    <Pressable onPress={onPress} style={styles.listItem}>
      <Text style={styles.title}>{item.title}</Text>
      <Text style={styles.subtitle}>{item.subtitle}</Text>
    </Pressable>
  );
});

// Memoize expensive computations
const UserList = ({ users, searchTerm }) => {
  const filteredUsers = useMemo(() => {
    console.log('Filtering users...');
    return users.filter(user => 
      user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [users, searchTerm]);

  const handleUserPress = useCallback((userId) => {
    console.log('User pressed:', userId);
    // Navigate to user profile
  }, []);

  return (
    <FlatList
      data={filteredUsers}
      keyExtractor={(item) => item.id.toString()}
      renderItem={({ item }) => (
        <ExpensiveListItem
          item={item}
          onPress={() => handleUserPress(item.id)}
        />
      )}
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      updateCellsBatchingPeriod={50}
    />
  );
};
```

### Component Splitting
```jsx path=null start=null
// Bad: Heavy component with multiple responsibilities
const HeavyComponent = ({ users, posts, comments }) => {
  return (
    <ScrollView>
      {/* Heavy rendering logic */}
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
      {posts.map(post => (
        <PostCard key={post.id} post={post} />
      ))}
      {comments.map(comment => (
        <CommentCard key={comment.id} comment={comment} />
      ))}
    </ScrollView>
  );
};

// Good: Split into smaller, focused components
const UserSection = memo(({ users }) => (
  <View>
    {users.map(user => (
      <UserCard key={user.id} user={user} />
    ))}
  </View>
));

const PostSection = memo(({ posts }) => (
  <View>
    {posts.map(post => (
      <PostCard key={post.id} post={post} />
    ))}
  </View>
));

const OptimizedComponent = ({ users, posts, comments }) => {
  return (
    <ScrollView>
      <UserSection users={users} />
      <PostSection posts={posts} />
      <CommentSection comments={comments} />
    </ScrollView>
  );
};
```

---

## FlatList Optimization

Optimize large lists for better performance.

### Advanced FlatList Configuration
```jsx path=null start=null
const OptimizedFlatList = ({ data }) => {
  const renderItem = useCallback(({ item, index }) => {
    return <ListItem item={item} index={index} />;
  }, []);

  const getItemLayout = useCallback((data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index,
  }), []);

  const keyExtractor = useCallback((item) => item.id.toString(), []);

  return (
    <FlatList
      data={data}
      renderItem={renderItem}
      keyExtractor={keyExtractor}
      
      // Performance optimizations
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      updateCellsBatchingPeriod={50}
      initialNumToRender={10}
      windowSize={10}
      
      // Item layout optimization (if items have consistent height)
      getItemLayout={getItemLayout}
      
      // Memory optimization
      legacyImplementation={false}
    />
  );
};

// Custom hook for paginated data
const usePaginatedData = (initialData, fetchMore) => {
  const [data, setData] = useState(initialData);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;
    
    setLoading(true);
    try {
      const newData = await fetchMore(data.length);
      if (newData.length === 0) {
        setHasMore(false);
      } else {
        setData(prevData => [...prevData, ...newData]);
      }
    } catch (error) {
      console.error('Failed to load more data:', error);
    } finally {
      setLoading(false);
    }
  }, [data.length, loading, hasMore, fetchMore]);

  return { data, loading, hasMore, loadMore };
};
```

### Virtual List for Large Datasets
```jsx path=null start=null
import { VirtualizedList } from 'react-native';

const VirtualList = ({ data }) => {
  const getItem = (data, index) => data[index];
  const getItemCount = (data) => data.length;

  const renderItem = ({ item, index }) => (
    <View style={[styles.listItem, { height: ITEM_HEIGHT }]}>
      <Text>{item.title}</Text>
    </View>
  );

  return (
    <VirtualizedList
      data={data}
      initialNumToRender={4}
      renderItem={renderItem}
      keyExtractor={(item) => item.id}
      getItemCount={getItemCount}
      getItem={getItem}
      removeClippedSubviews={true}
    />
  );
};
```

---

## Image Optimization

Optimize image loading and rendering for better performance.

### Image Caching and Optimization
```jsx path=null start=null
import FastImage from 'react-native-fast-image';

const OptimizedImage = ({ uri, style, fallbackSource }) => {
  return (
    <FastImage
      style={style}
      source={{
        uri: uri,
        priority: FastImage.priority.normal,
        cache: FastImage.cacheControl.immutable,
      }}
      fallback={fallbackSource}
      resizeMode={FastImage.resizeMode.cover}
      onLoadStart={() => console.log('Image loading started')}
      onLoad={() => console.log('Image loaded')}
      onError={() => console.log('Image failed to load')}
    />
  );
};

// Image preloading for better UX
const preloadImages = (imageUris) => {
  const sources = imageUris.map(uri => ({ uri }));
  FastImage.preload(sources);
};

// Use appropriate image sizes
const ResponsiveImage = ({ uri, width, height }) => {
  // Generate appropriate image URL with size parameters
  const optimizedUri = `${uri}?w=${Math.round(width * 2)}&h=${Math.round(height * 2)}`;
  
  return (
    <FastImage
      source={{ uri: optimizedUri }}
      style={{ width, height }}
      resizeMode={FastImage.resizeMode.cover}
    />
  );
};
```

### Lazy Loading Images
```jsx path=null start=null
import { useIntersectionObserver } from './hooks/useIntersectionObserver';

const LazyImage = ({ uri, style, placeholder }) => {
  const [imageRef, isVisible] = useIntersectionObserver({
    threshold: 0.1,
    triggerOnce: true,
  });

  return (
    <View ref={imageRef} style={style}>
      {isVisible ? (
        <FastImage source={{ uri }} style={style} />
      ) : (
        placeholder || <View style={[style, styles.placeholder]} />
      )}
    </View>
  );
};

// Custom hook for intersection observer
const useIntersectionObserver = ({ threshold = 0, triggerOnce = false }) => {
  const [isVisible, setIsVisible] = useState(false);
  const elementRef = useRef(null);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    // Simple visibility check implementation
    const checkVisibility = () => {
      element.measure((x, y, width, height, pageX, pageY) => {
        const windowHeight = Dimensions.get('window').height;
        const isInView = pageY < windowHeight && pageY + height > 0;
        
        if (isInView && (!triggerOnce || !isVisible)) {
          setIsVisible(true);
        } else if (!triggerOnce && !isInView) {
          setIsVisible(false);
        }
      });
    };

    checkVisibility();
    return () => {};
  }, [threshold, triggerOnce, isVisible]);

  return [elementRef, isVisible];
};
```

---

## Memory Management

Prevent memory leaks and optimize memory usage.

### Memory Leak Prevention
```jsx path=null start=null
// Cleanup subscriptions and timeouts
const useCleanupEffect = () => {
  useEffect(() => {
    const subscription = EventEmitter.addListener('event', handleEvent);
    const timer = setInterval(updateData, 5000);
    const fetchController = new AbortController();

    // Async operation with cleanup
    fetchData(fetchController.signal);

    return () => {
      // Cleanup on unmount
      subscription.remove();
      clearInterval(timer);
      fetchController.abort();
    };
  }, []);
};

// Proper state cleanup
const useStateWithCleanup = (initialValue) => {
  const [state, setState] = useState(initialValue);
  const mountedRef = useRef(true);

  useEffect(() => {
    return () => {
      mountedRef.current = false;
    };
  }, []);

  const setStateIfMounted = useCallback((value) => {
    if (mountedRef.current) {
      setState(value);
    }
  }, []);

  return [state, setStateIfMounted];
};
```

### Weak References and Cleanup
```jsx path=null start=null
// Cache with automatic cleanup
class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }

  get(key) {
    const value = this.cache.get(key);
    if (value) {
      // Move to end (most recently used)
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Remove least recently used
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }

  clear() {
    this.cache.clear();
  }
}

// Global cache instance
const imageCache = new LRUCache(50);

// Component with cache usage
const CachedDataComponent = ({ dataId }) => {
  const [data, setData] = useState(null);

  useEffect(() => {
    const cached = imageCache.get(dataId);
    if (cached) {
      setData(cached);
    } else {
      fetchData(dataId).then(result => {
        imageCache.set(dataId, result);
        setData(result);
      });
    }
  }, [dataId]);

  return data ? <DataView data={data} /> : <LoadingSpinner />;
};
```

---

## Bundle Optimization

Reduce bundle size and improve app startup time.

### Code Splitting and Lazy Loading
```jsx path=null start=null
import React, { lazy, Suspense } from 'react';

// Lazy load heavy components
const HeavyChart = lazy(() => import('./components/HeavyChart'));
const VideoPlayer = lazy(() => import('./components/VideoPlayer'));

const LazyLoadedScreen = () => {
  const [showChart, setShowChart] = useState(false);

  return (
    <View>
      <Button 
        title="Show Chart" 
        onPress={() => setShowChart(true)} 
      />
      
      {showChart && (
        <Suspense fallback={<ActivityIndicator size="large" />}>
          <HeavyChart data={chartData} />
        </Suspense>
      )}
    </View>
  );
};

// Dynamic imports for libraries
const loadChartLibrary = async () => {
  const chartLib = await import('react-native-chart-kit');
  return chartLib;
};
```

### Bundle Analysis
```bash path=null start=null
# Analyze bundle size
npx react-native bundle --platform android --dev false --entry-file index.js --bundle-output android-release.bundle --assets-dest /tmp

# Use bundle analyzer
npm install --save-dev react-native-bundle-visualizer
npx react-native-bundle-visualizer
```

---

## Native Module Optimization

Optimize interactions between JavaScript and native code.

### Batch Native Calls
```jsx path=null start=null
// Bad: Multiple individual native calls
const inefficientUpdates = async () => {
  await AsyncStorage.setItem('key1', value1);
  await AsyncStorage.setItem('key2', value2);
  await AsyncStorage.setItem('key3', value3);
};

// Good: Batch native operations
const efficientUpdates = async () => {
  const updates = [
    ['key1', value1],
    ['key2', value2],
    ['key3', value3],
  ];
  await AsyncStorage.multiSet(updates);
};

// Batch API calls
const batchApiCalls = async (requests) => {
  const results = await Promise.allSettled(
    requests.map(request => fetch(request.url))
  );
  return results;
};
```

### Reduce Bridge Traffic
```jsx path=null start=null
// Use react-native-reanimated for animations that run on UI thread
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnUI,
} from 'react-native-reanimated';

const PerformantAnimation = () => {
  const translateX = useSharedValue(0);

  // Animation runs on UI thread, no bridge communication
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value }],
    };
  });

  const moveBox = () => {
    translateX.value = withSpring(100);
  };

  return (
    <View>
      <Animated.View style={[styles.box, animatedStyle]} />
      <Button title="Move" onPress={moveBox} />
    </View>
  );
};
```

---

## Performance Monitoring

Track and monitor app performance in production.

### Custom Performance Metrics
```jsx path=null start=null
class PerformanceMonitor {
  static startTiming(label) {
    console.time(label);
    return {
      end: () => console.timeEnd(label),
    };
  }

  static measureRender(Component) {
    return React.forwardRef((props, ref) => {
      const timer = PerformanceMonitor.startTiming(`${Component.name} render`);
      
      useEffect(() => {
        timer.end();
      });

      return <Component {...props} ref={ref} />;
    });
  }

  static trackNavigation(screenName) {
    const startTime = Date.now();
    
    return () => {
      const endTime = Date.now();
      console.log(`Navigation to ${screenName}: ${endTime - startTime}ms`);
    };
  }
}

// Usage
const ProfileScreen = PerformanceMonitor.measureRender(() => {
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    const stopTracking = PerformanceMonitor.trackNavigation('Profile');
    
    fetchUserData().then(data => {
      setUserData(data);
      stopTracking();
    });
  }, []);

  return <UserProfile data={userData} />;
});
```

### Memory Usage Tracking
```jsx path=null start=null
// Custom hook for memory monitoring
const useMemoryMonitor = (componentName) => {
  useEffect(() => {
    if (__DEV__) {
      const checkMemory = () => {
        // Get memory usage (React Native specific)
        console.log(`Memory usage for ${componentName}:`, performance.memory);
      };

      const interval = setInterval(checkMemory, 5000);
      return () => clearInterval(interval);
    }
  }, [componentName]);
};

// Component with memory monitoring
const MonitoredComponent = () => {
  useMemoryMonitor('MonitoredComponent');
  
  return <YourComponent />;
};
```

---

## 💡 Key Performance Tips

1. **Use FlatList for large datasets** instead of ScrollView with map
2. **Implement lazy loading** for images and heavy components
3. **Memoize expensive computations** with useMemo and useCallback
4. **Remove clipped subviews** in scrollable lists
5. **Use react-native-reanimated** for complex animations
6. **Optimize images** with appropriate sizes and caching
7. **Minimize bridge communication** between JS and native threads
8. **Profile your app regularly** using built-in dev tools
9. **Clean up subscriptions and timers** to prevent memory leaks
10. **Consider code splitting** for large applications

---

## 🔗 Related Notes
- [[13.Popular React Native Libraries]] - Optimizing third-party libraries
- [[15.Advanced Animations]] - Performance-focused animations
- [[Debugging and Testing]] - Performance debugging tools

## 📚 Next Steps
1. Profile your app using React Native performance tools
2. Implement FlatList optimizations for large datasets
3. Set up performance monitoring in production
4. Move on to [[15.Advanced Animations]]

---
*Tags: #react-native #performance #optimization #stage-5 #memory #animations #bundle-size*
