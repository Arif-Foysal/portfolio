---
title: "Handling User Input"
description: "Master user input handling, forms, and event management in React Native"
navigation:
  icon: i-lucide-house
---

# Handling User Input

#react-native #forms #input #events #stage-2

> Master user input handling, forms, and event management in React Native

## 🔗 Navigation
← [[5.React Navigation]] | → [[7.Lists and Data Display]]

---

## TextInput Fundamentals

The core component for capturing text input from users.

```jsx path=null start=null
import React, { useState } from 'react';
import { View, TextInput, Text, StyleSheet } from 'react-native';

const BasicTextInput = () => {
  const [text, setText] = useState('');
  const [email, setEmail] = useState('');

  return (
    <View style={styles.container}>
      {/* Basic text input */}
      <TextInput
        style={styles.input}
        value={text}
        onChangeText={setText}
        placeholder="Enter your name"
        placeholderTextColor="#999"
      />

      {/* Email input with keyboard type */}
      <TextInput
        style={styles.input}
        value={email}
        onChangeText={setEmail}
        placeholder="Enter your email"
        keyboardType="email-address"
        autoCapitalize="none"
        autoCompleteType="email"
      />

      <Text>Name: {text}</Text>
      <Text>Email: {email}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  input: {
    height: 50,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 15,
    marginBottom: 15,
    fontSize: 16,
    backgroundColor: '#fff',
  },
});
```

### TextInput Props Reference
```jsx path=null start=null
<TextInput
  // Value and change handling
  value={text}
  onChangeText={setText}
  defaultValue="Initial value"
  
  // Keyboard configuration
  keyboardType="default" | "numeric" | "email-address" | "phone-pad" | "url"
  autoCapitalize="none" | "sentences" | "words" | "characters"
  autoCorrect={false}
  autoCompleteType="email" | "password" | "name" | "phone" | "username"
  
  // Input behavior
  secureTextEntry={true} // For passwords
  multiline={true} // For text areas
  numberOfLines={4} // For multiline
  maxLength={100}
  editable={true}
  
  // Appearance
  placeholder="Placeholder text"
  placeholderTextColor="#999"
  selectionColor="#007AFF"
  
  // Events
  onFocus={() => console.log('Input focused')}
  onBlur={() => console.log('Input lost focus')}
  onSubmitEditing={() => console.log('Submit pressed')}
  onContentSizeChange={() => console.log('Content size changed')}
  
  // Return key
  returnKeyType="done" | "go" | "next" | "search" | "send"
  onSubmitEditing={() => {/* Handle submit */}}
  blurOnSubmit={false} // Stay focused after submit
/>
```

---

## Form Creation & Management

Building comprehensive forms with validation and user experience enhancements.

```jsx path=null start=null
import React, { useState, useRef } from 'react';
import {
  View,
  TextInput,
  Text,
  Pressable,
  ScrollView,
  Alert,
  StyleSheet,
} from 'react-native';

const RegistrationForm = () => {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: '',
    phone: '',
    bio: '',
  });

  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Refs for input navigation
  const lastNameRef = useRef();
  const emailRef = useRef();
  const passwordRef = useRef();
  const confirmPasswordRef = useRef();
  const phoneRef = useRef();
  const bioRef = useRef();

  const updateField = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: ''
      }));
    }
  };

  const validateForm = () => {
    const newErrors = {};

    // Required fields
    if (!formData.firstName.trim()) {
      newErrors.firstName = 'First name is required';
    }
    
    if (!formData.lastName.trim()) {
      newErrors.lastName = 'Last name is required';
    }

    // Email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!emailRegex.test(formData.email)) {
      newErrors.email = 'Invalid email format';
    }

    // Password validation
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }

    // Confirm password
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }

    // Phone validation (optional but must be valid if provided)
    const phoneRegex = /^\+?[\d\s-()]+$/;
    if (formData.phone && !phoneRegex.test(formData.phone)) {
      newErrors.phone = 'Invalid phone number format';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      Alert.alert('Validation Error', 'Please correct the errors below');
      return;
    }

    setIsSubmitting(true);
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      Alert.alert('Success', 'Registration completed successfully!');
      
      // Reset form
      setFormData({
        firstName: '',
        lastName: '',
        email: '',
        password: '',
        confirmPassword: '',
        phone: '',
        bio: '',
      });
    } catch (error) {
      Alert.alert('Error', 'Registration failed. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <ScrollView style={styles.container} showsVerticalScrollIndicator={false}>
      <Text style={styles.title}>Create Account</Text>

      {/* First Name */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>First Name *</Text>
        <TextInput
          style={[styles.input, errors.firstName && styles.inputError]}
          value={formData.firstName}
          onChangeText={(value) => updateField('firstName', value)}
          placeholder="Enter your first name"
          returnKeyType="next"
          onSubmitEditing={() => lastNameRef.current?.focus()}
          blurOnSubmit={false}
        />
        {errors.firstName && <Text style={styles.errorText}>{errors.firstName}</Text>}
      </View>

      {/* Last Name */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Last Name *</Text>
        <TextInput
          ref={lastNameRef}
          style={[styles.input, errors.lastName && styles.inputError]}
          value={formData.lastName}
          onChangeText={(value) => updateField('lastName', value)}
          placeholder="Enter your last name"
          returnKeyType="next"
          onSubmitEditing={() => emailRef.current?.focus()}
          blurOnSubmit={false}
        />
        {errors.lastName && <Text style={styles.errorText}>{errors.lastName}</Text>}
      </View>

      {/* Email */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Email Address *</Text>
        <TextInput
          ref={emailRef}
          style={[styles.input, errors.email && styles.inputError]}
          value={formData.email}
          onChangeText={(value) => updateField('email', value.toLowerCase())}
          placeholder="Enter your email"
          keyboardType="email-address"
          autoCapitalize="none"
          autoCompleteType="email"
          returnKeyType="next"
          onSubmitEditing={() => passwordRef.current?.focus()}
          blurOnSubmit={false}
        />
        {errors.email && <Text style={styles.errorText}>{errors.email}</Text>}
      </View>

      {/* Password */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Password *</Text>
        <TextInput
          ref={passwordRef}
          style={[styles.input, errors.password && styles.inputError]}
          value={formData.password}
          onChangeText={(value) => updateField('password', value)}
          placeholder="Enter your password"
          secureTextEntry
          returnKeyType="next"
          onSubmitEditing={() => confirmPasswordRef.current?.focus()}
          blurOnSubmit={false}
        />
        {errors.password && <Text style={styles.errorText}>{errors.password}</Text>}
      </View>

      {/* Confirm Password */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Confirm Password *</Text>
        <TextInput
          ref={confirmPasswordRef}
          style={[styles.input, errors.confirmPassword && styles.inputError]}
          value={formData.confirmPassword}
          onChangeText={(value) => updateField('confirmPassword', value)}
          placeholder="Confirm your password"
          secureTextEntry
          returnKeyType="next"
          onSubmitEditing={() => phoneRef.current?.focus()}
          blurOnSubmit={false}
        />
        {errors.confirmPassword && <Text style={styles.errorText}>{errors.confirmPassword}</Text>}
      </View>

      {/* Phone */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Phone Number</Text>
        <TextInput
          ref={phoneRef}
          style={[styles.input, errors.phone && styles.inputError]}
          value={formData.phone}
          onChangeText={(value) => updateField('phone', value)}
          placeholder="Enter your phone number"
          keyboardType="phone-pad"
          returnKeyType="next"
          onSubmitEditing={() => bioRef.current?.focus()}
          blurOnSubmit={false}
        />
        {errors.phone && <Text style={styles.errorText}>{errors.phone}</Text>}
      </View>

      {/* Bio */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Bio</Text>
        <TextInput
          ref={bioRef}
          style={[styles.input, styles.textArea]}
          value={formData.bio}
          onChangeText={(value) => updateField('bio', value)}
          placeholder="Tell us about yourself..."
          multiline
          numberOfLines={4}
          textAlignVertical="top"
          maxLength={500}
        />
        <Text style={styles.characterCount}>
          {formData.bio.length}/500 characters
        </Text>
      </View>

      {/* Submit Button */}
      <Pressable
        style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
        onPress={handleSubmit}
        disabled={isSubmitting}
      >
        <Text style={styles.submitButtonText}>
          {isSubmitting ? 'Creating Account...' : 'Create Account'}
        </Text>
      </Pressable>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
    color: '#333',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
    color: '#333',
  },
  input: {
    height: 50,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 15,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  inputError: {
    borderColor: '#ff6b6b',
  },
  textArea: {
    height: 100,
    paddingTop: 15,
  },
  errorText: {
    color: '#ff6b6b',
    fontSize: 14,
    marginTop: 5,
  },
  characterCount: {
    textAlign: 'right',
    fontSize: 12,
    color: '#999',
    marginTop: 5,
  },
  submitButton: {
    backgroundColor: '#007AFF',
    height: 50,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 20,
    marginBottom: 40,
  },
  submitButtonDisabled: {
    backgroundColor: '#ccc',
  },
  submitButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});
```

---

## Button Interactions

Different types of buttons and interaction patterns.

```jsx path=null start=null
import React, { useState } from 'react';
import { View, Text, Pressable, Alert, StyleSheet } from 'react-native';

const ButtonExamples = () => {
  const [pressCount, setPressCount] = useState(0);
  const [isPressed, setIsPressed] = useState(false);

  const handlePress = () => {
    setPressCount(prev => prev + 1);
    Alert.alert('Button Pressed', `Count: ${pressCount + 1}`);
  };

  const handleLongPress = () => {
    Alert.alert('Long Press', 'Button was held down');
  };

  const handlePressIn = () => {
    setIsPressed(true);
  };

  const handlePressOut = () => {
    setIsPressed(false);
  };

  return (
    <View style={styles.container}>
      {/* Primary Button */}
      <Pressable
        style={({ pressed }) => [
          styles.button,
          styles.primaryButton,
          pressed && styles.buttonPressed
        ]}
        onPress={handlePress}
      >
        <Text style={[styles.buttonText, styles.primaryButtonText]}>
          Primary Action
        </Text>
      </Pressable>

      {/* Secondary Button */}
      <Pressable
        style={({ pressed }) => [
          styles.button,
          styles.secondaryButton,
          pressed && styles.secondaryButtonPressed
        ]}
        onPress={() => Alert.alert('Secondary', 'Secondary action')}
      >
        <Text style={[styles.buttonText, styles.secondaryButtonText]}>
          Secondary Action
        </Text>
      </Pressable>

      {/* Long Press Button */}
      <Pressable
        style={styles.button}
        onPress={() => console.log('Regular press')}
        onLongPress={handleLongPress}
        delayLongPress={800} // 800ms for long press
      >
        <Text style={styles.buttonText}>
          Press & Hold
        </Text>
      </Pressable>

      {/* Custom Press Feedback */}
      <Pressable
        style={[
          styles.button,
          styles.customButton,
          isPressed && styles.customButtonPressed
        ]}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        onPress={() => Alert.alert('Custom Feedback')}
      >
        <Text style={styles.buttonText}>
          Custom Feedback
        </Text>
      </Pressable>

      {/* Disabled Button */}
      <Pressable
        style={[styles.button, styles.disabledButton]}
        disabled={true}
        onPress={() => {}} // Won't be called when disabled
      >
        <Text style={[styles.buttonText, styles.disabledButtonText]}>
          Disabled Button
        </Text>
      </Pressable>

      {/* Android Ripple Effect */}
      <Pressable
        style={styles.button}
        android_ripple={{
          color: 'rgba(0, 122, 255, 0.3)',
          borderless: false,
        }}
        onPress={() => Alert.alert('Android Ripple')}
      >
        <Text style={styles.buttonText}>
          Android Ripple
        </Text>
      </Pressable>

      <Text style={styles.counter}>Press Count: {pressCount}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
  },
  button: {
    height: 50,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 15,
    paddingHorizontal: 20,
  },
  buttonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  primaryButton: {
    backgroundColor: '#007AFF',
  },
  primaryButtonText: {
    color: '#fff',
  },
  buttonPressed: {
    backgroundColor: '#005bb5',
    transform: [{ scale: 0.96 }],
  },
  secondaryButton: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: '#007AFF',
  },
  secondaryButtonText: {
    color: '#007AFF',
  },
  secondaryButtonPressed: {
    backgroundColor: 'rgba(0, 122, 255, 0.1)',
  },
  customButton: {
    backgroundColor: '#28a745',
  },
  customButtonPressed: {
    backgroundColor: '#1e7e34',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  disabledButton: {
    backgroundColor: '#e9ecef',
  },
  disabledButtonText: {
    color: '#6c757d',
  },
  counter: {
    textAlign: 'center',
    fontSize: 18,
    fontWeight: 'bold',
    marginTop: 20,
    color: '#333',
  },
});
```

---

## Touch Events & Gestures

Advanced touch handling and gesture recognition.

```jsx path=null start=null
import React, { useState } from 'react';
import { View, Text, PanGestureHandler, State } from 'react-native-gesture-handler';
import Animated, {
  useAnimatedGestureHandler,
  useAnimatedStyle,
  useSharedValue,
  withSpring,
} from 'react-native-reanimated';

// Simple touch tracking without gesture handler
const TouchTracker = () => {
  const [touchData, setTouchData] = useState({
    x: 0,
    y: 0,
    touching: false,
  });

  const handleTouchStart = (event) => {
    const { locationX, locationY } = event.nativeEvent;
    setTouchData({
      x: Math.round(locationX),
      y: Math.round(locationY),
      touching: true,
    });
  };

  const handleTouchMove = (event) => {
    const { locationX, locationY } = event.nativeEvent;
    setTouchData(prev => ({
      ...prev,
      x: Math.round(locationX),
      y: Math.round(locationY),
    }));
  };

  const handleTouchEnd = () => {
    setTouchData(prev => ({
      ...prev,
      touching: false,
    }));
  };

  return (
    <View
      style={styles.touchArea}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
    >
      <Text style={styles.touchText}>
        Touch Position: ({touchData.x}, {touchData.y})
      </Text>
      <Text style={styles.touchText}>
        Status: {touchData.touching ? 'Touching' : 'Not Touching'}
      </Text>
    </View>
  );
};

// Advanced gesture handling with react-native-gesture-handler
const DraggableBox = () => {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);

  const gestureHandler = useAnimatedGestureHandler({
    onStart: (_, context) => {
      context.startX = translateX.value;
      context.startY = translateY.value;
    },
    onActive: (event, context) => {
      translateX.value = context.startX + event.translationX;
      translateY.value = context.startY + event.translationY;
    },
    onEnd: () => {
      // Snap back to center with spring animation
      translateX.value = withSpring(0);
      translateY.value = withSpring(0);
    },
  });

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
      ],
    };
  });

  return (
    <View style={styles.gestureContainer}>
      <PanGestureHandler onGestureEvent={gestureHandler}>
        <Animated.View style={[styles.draggableBox, animatedStyle]}>
          <Text style={styles.boxText}>Drag Me!</Text>
        </Animated.View>
      </PanGestureHandler>
    </View>
  );
};

const styles = StyleSheet.create({
  touchArea: {
    height: 200,
    backgroundColor: '#e3f2fd',
    borderRadius: 10,
    padding: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  touchText: {
    fontSize: 16,
    marginBottom: 10,
    color: '#1976d2',
  },
  gestureContainer: {
    height: 300,
    backgroundColor: '#f5f5f5',
    justifyContent: 'center',
    alignItems: 'center',
  },
  draggableBox: {
    width: 80,
    height: 80,
    backgroundColor: '#ff6b6b',
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
  },
  boxText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});
```

---

## Input Validation Patterns

Common validation patterns and custom validators.

```jsx path=null start=null
// validation/validators.js
export const validators = {
  required: (value) => {
    if (!value || !value.toString().trim()) {
      return 'This field is required';
    }
    return null;
  },

  email: (value) => {
    if (!value) return null; // Let required handle empty values
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      return 'Please enter a valid email address';
    }
    return null;
  },

  minLength: (min) => (value) => {
    if (!value) return null;
    
    if (value.length < min) {
      return `Must be at least ${min} characters long`;
    }
    return null;
  },

  maxLength: (max) => (value) => {
    if (!value) return null;
    
    if (value.length > max) {
      return `Must be no more than ${max} characters long`;
    }
    return null;
  },

  phone: (value) => {
    if (!value) return null;
    
    const phoneRegex = /^\+?[\d\s-()]{10,}$/;
    if (!phoneRegex.test(value.replace(/\s/g, ''))) {
      return 'Please enter a valid phone number';
    }
    return null;
  },

  strongPassword: (value) => {
    if (!value) return null;
    
    const hasLength = value.length >= 8;
    const hasUppercase = /[A-Z]/.test(value);
    const hasLowercase = /[a-z]/.test(value);
    const hasNumber = /\d/.test(value);
    const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(value);
    
    if (!hasLength) {
      return 'Password must be at least 8 characters long';
    }
    if (!hasUppercase) {
      return 'Password must contain at least one uppercase letter';
    }
    if (!hasLowercase) {
      return 'Password must contain at least one lowercase letter';
    }
    if (!hasNumber) {
      return 'Password must contain at least one number';
    }
    if (!hasSpecial) {
      return 'Password must contain at least one special character';
    }
    return null;
  },

  match: (otherField, otherLabel) => (value, allValues) => {
    if (!value) return null;
    
    if (value !== allValues[otherField]) {
      return `Must match ${otherLabel}`;
    }
    return null;
  },
};

// Custom hook for form validation
import { useState, useCallback } from 'react';

export const useFormValidation = (initialValues, validationRules) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const validateField = useCallback((fieldName, value) => {
    const rules = validationRules[fieldName];
    if (!rules) return null;

    for (const rule of rules) {
      const error = rule(value, values);
      if (error) return error;
    }
    return null;
  }, [validationRules, values]);

  const validateAll = useCallback(() => {
    const newErrors = {};
    let isValid = true;

    Object.keys(validationRules).forEach(fieldName => {
      const error = validateField(fieldName, values[fieldName]);
      if (error) {
        newErrors[fieldName] = error;
        isValid = false;
      }
    });

    setErrors(newErrors);
    return isValid;
  }, [values, validateField, validationRules]);

  const setValue = useCallback((fieldName, value) => {
    setValues(prev => ({
      ...prev,
      [fieldName]: value,
    }));

    // Clear error if field becomes valid
    if (touched[fieldName]) {
      const error = validateField(fieldName, value);
      setErrors(prev => ({
        ...prev,
        [fieldName]: error,
      }));
    }
  }, [validateField, touched]);

  const setTouched = useCallback((fieldName) => {
    setTouched(prev => ({
      ...prev,
      [fieldName]: true,
    }));

    // Validate field when it's touched
    const error = validateField(fieldName, values[fieldName]);
    setErrors(prev => ({
      ...prev,
      [fieldName]: error,
    }));
  }, [validateField, values]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    setValue,
    setTouched,
    validateAll,
    reset,
  };
};

// Usage example
const LoginForm = () => {
  const {
    values,
    errors,
    touched,
    setValue,
    setTouched,
    validateAll,
    reset,
  } = useFormValidation(
    { email: '', password: '' },
    {
      email: [validators.required, validators.email],
      password: [validators.required, validators.minLength(6)],
    }
  );

  const handleSubmit = async () => {
    if (validateAll()) {
      // Form is valid, proceed with submission
      console.log('Form data:', values);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={[styles.input, errors.email && touched.email && styles.inputError]}
        value={values.email}
        onChangeText={(text) => setValue('email', text)}
        onBlur={() => setTouched('email')}
        placeholder="Email"
        keyboardType="email-address"
        autoCapitalize="none"
      />
      {errors.email && touched.email && (
        <Text style={styles.errorText}>{errors.email}</Text>
      )}

      <TextInput
        style={[styles.input, errors.password && touched.password && styles.inputError]}
        value={values.password}
        onChangeText={(text) => setValue('password', text)}
        onBlur={() => setTouched('password')}
        placeholder="Password"
        secureTextEntry
      />
      {errors.password && touched.password && (
        <Text style={styles.errorText}>{errors.password}</Text>
      )}

      <Pressable style={styles.submitButton} onPress={handleSubmit}>
        <Text style={styles.submitButtonText}>Login</Text>
      </Pressable>
    </View>
  );
};
```

---

## 💡 Key Takeaways

1. **TextInput** is the foundation for all text input in React Native
2. **Form validation** should be immediate and user-friendly
3. **Button interactions** can be customized with Pressable
4. **Focus management** improves form navigation experience
5. **Input refs** enable programmatic focus control
6. **Touch events** provide granular control over user interactions
7. **Custom validation hooks** make forms reusable and maintainable

---

## 🔗 Related Notes
- [[3.Core React Native Components]] - Input component fundamentals
- [[5.React Navigation]] - Navigating from forms
- [[10.Data Fetching]] - Submitting form data to APIs

## 📚 Next Steps
1. Practice building complex forms with validation
2. Implement custom input components
3. Add touch gestures to enhance user experience
4. Move on to [[7.Lists and Data Display]]

---
*Tags: #react-native #forms #input #events #stage-2 #validation #textinput*
