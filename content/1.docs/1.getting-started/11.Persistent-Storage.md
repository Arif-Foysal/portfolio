---
title: "Persistent Storage"
description: "Master data persistence, local storage, and offline data management in React Native"
navigation:
  icon: i-lucide-house
---

# Persistent Storage

#react-native #storage #asyncstorage #database #persistence #stage-3

> Master data persistence, local storage, and offline data management in React Native

## 🔗 Navigation
← [[10.Data Fetching]] | → [[12.Platform APIs]]

---

## AsyncStorage Fundamentals

React Native's built-in key-value storage system.

```jsx path=null start=null
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, Alert, StyleSheet } from 'react-native';

const AsyncStorageBasics = () => {
  const [value, setValue] = useState('');
  const [storedValue, setStoredValue] = useState('');
  const [loading, setLoading] = useState(false);

  // Store a simple value
  const storeValue = async () => {
    try {
      setLoading(true);
      await AsyncStorage.setItem('user_input', value);
      Alert.alert('Success', 'Value stored successfully');
      loadValue(); // Refresh the displayed value
    } catch (error) {
      Alert.alert('Error', 'Failed to store value');
      console.error('Storage error:', error);
    } finally {
      setLoading(false);
    }
  };

  // Load a value
  const loadValue = async () => {
    try {
      setLoading(true);
      const stored = await AsyncStorage.getItem('user_input');
      setStoredValue(stored || 'No value stored');
    } catch (error) {
      Alert.alert('Error', 'Failed to load value');
      console.error('Load error:', error);
    } finally {
      setLoading(false);
    }
  };

  // Remove a value
  const removeValue = async () => {
    try {
      setLoading(true);
      await AsyncStorage.removeItem('user_input');
      setStoredValue('No value stored');
      Alert.alert('Success', 'Value removed successfully');
    } catch (error) {
      Alert.alert('Error', 'Failed to remove value');
      console.error('Remove error:', error);
    } finally {
      setLoading(false);
    }
  };

  // Clear all AsyncStorage
  const clearAll = async () => {
    Alert.alert(
      'Confirm Clear',
      'Are you sure you want to clear all stored data?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Clear All',
          style: 'destructive',
          onPress: async () => {
            try {
              setLoading(true);
              await AsyncStorage.clear();
              setStoredValue('No value stored');
              Alert.alert('Success', 'All data cleared');
            } catch (error) {
              Alert.alert('Error', 'Failed to clear data');
              console.error('Clear error:', error);
            } finally {
              setLoading(false);
            }
          },
        },
      ]
    );
  };

  useEffect(() => {
    loadValue();
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>AsyncStorage Demo</Text>
      
      <TextInput
        style={styles.input}
        value={value}
        onChangeText={setValue}
        placeholder="Enter a value to store"
      />

      <View style={styles.buttonContainer}>
        <Button
          title="Store Value"
          onPress={storeValue}
          disabled={loading || !value.trim()}
        />
        <Button title="Load Value" onPress={loadValue} disabled={loading} />
        <Button title="Remove Value" onPress={removeValue} disabled={loading} />
        <Button title="Clear All" onPress={clearAll} disabled={loading} />
      </View>

      <View style={styles.resultContainer}>
        <Text style={styles.label}>Stored Value:</Text>
        <Text style={styles.value}>{storedValue}</Text>
      </View>

      {loading && <Text style={styles.loading}>Loading...</Text>}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 10,
    borderRadius: 5,
    backgroundColor: '#fff',
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  resultContainer: {
    backgroundColor: '#fff',
    padding: 15,
    borderRadius: 5,
    marginBottom: 20,
  },
  label: {
    fontWeight: 'bold',
    marginBottom: 5,
  },
  value: {
    color: '#666',
  },
  loading: {
    textAlign: 'center',
    fontStyle: 'italic',
    color: '#666',
  },
});
```

---

## Storing Complex Data

Working with objects, arrays, and structured data.

```jsx path=null start=null
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { useState, useEffect } from 'react';

// Storage utility functions
const StorageUtils = {
  // Store object
  setObject: async (key, object) => {
    try {
      const jsonString = JSON.stringify(object);
      await AsyncStorage.setItem(key, jsonString);
      return true;
    } catch (error) {
      console.error('Failed to store object:', error);
      return false;
    }
  },

  // Get object
  getObject: async (key, defaultValue = null) => {
    try {
      const jsonString = await AsyncStorage.getItem(key);
      return jsonString ? JSON.parse(jsonString) : defaultValue;
    } catch (error) {
      console.error('Failed to get object:', error);
      return defaultValue;
    }
  },

  // Store array
  setArray: async (key, array) => {
    return StorageUtils.setObject(key, array);
  },

  // Get array
  getArray: async (key, defaultValue = []) => {
    return StorageUtils.getObject(key, defaultValue);
  },

  // Append to array
  appendToArray: async (key, item) => {
    try {
      const existingArray = await StorageUtils.getArray(key, []);
      const updatedArray = [...existingArray, item];
      return StorageUtils.setArray(key, updatedArray);
    } catch (error) {
      console.error('Failed to append to array:', error);
      return false;
    }
  },

  // Remove from array by index
  removeFromArray: async (key, index) => {
    try {
      const existingArray = await StorageUtils.getArray(key, []);
      const updatedArray = existingArray.filter((_, i) => i !== index);
      return StorageUtils.setArray(key, updatedArray);
    } catch (error) {
      console.error('Failed to remove from array:', error);
      return false;
    }
  },

  // Update array item by index
  updateArrayItem: async (key, index, newItem) => {
    try {
      const existingArray = await StorageUtils.getArray(key, []);
      const updatedArray = existingArray.map((item, i) => 
        i === index ? newItem : item
      );
      return StorageUtils.setArray(key, updatedArray);
    } catch (error) {
      console.error('Failed to update array item:', error);
      return false;
    }
  },

  // Get multiple values at once
  getMultiple: async (keys) => {
    try {
      const keyValuePairs = await AsyncStorage.multiGet(keys);
      const result = {};
      
      keyValuePairs.forEach(([key, value]) => {
        result[key] = value ? JSON.parse(value) : null;
      });
      
      return result;
    } catch (error) {
      console.error('Failed to get multiple values:', error);
      return {};
    }
  },

  // Set multiple values at once
  setMultiple: async (keyValuePairs) => {
    try {
      const pairs = keyValuePairs.map(([key, value]) => [
        key,
        JSON.stringify(value),
      ]);
      await AsyncStorage.multiSet(pairs);
      return true;
    } catch (error) {
      console.error('Failed to set multiple values:', error);
      return false;
    }
  },
};

// Example: User Profile Management
const UserProfileManager = () => {
  const [profile, setProfile] = useState({
    name: '',
    email: '',
    age: '',
    preferences: {
      notifications: true,
      darkMode: false,
      language: 'en',
    },
  });
  const [loading, setLoading] = useState(false);

  // Load profile from storage
  const loadProfile = async () => {
    setLoading(true);
    const savedProfile = await StorageUtils.getObject('user_profile', {
      name: '',
      email: '',
      age: '',
      preferences: {
        notifications: true,
        darkMode: false,
        language: 'en',
      },
    });
    setProfile(savedProfile);
    setLoading(false);
  };

  // Save profile to storage
  const saveProfile = async () => {
    setLoading(true);
    const success = await StorageUtils.setObject('user_profile', profile);
    if (success) {
      Alert.alert('Success', 'Profile saved successfully');
    } else {
      Alert.alert('Error', 'Failed to save profile');
    }
    setLoading(false);
  };

  // Update profile field
  const updateProfile = (field, value) => {
    setProfile(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  // Update preference
  const updatePreference = (preference, value) => {
    setProfile(prev => ({
      ...prev,
      preferences: {
        ...prev.preferences,
        [preference]: value,
      },
    }));
  };

  useEffect(() => {
    loadProfile();
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>User Profile</Text>
      
      <TextInput
        style={styles.input}
        placeholder="Name"
        value={profile.name}
        onChangeText={(text) => updateProfile('name', text)}
      />
      
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={profile.email}
        onChangeText={(text) => updateProfile('email', text)}
        keyboardType="email-address"
        autoCapitalize="none"
      />
      
      <TextInput
        style={styles.input}
        placeholder="Age"
        value={profile.age}
        onChangeText={(text) => updateProfile('age', text)}
        keyboardType="numeric"
      />

      <View style={styles.switchContainer}>
        <Text>Notifications</Text>
        <Switch
          value={profile.preferences.notifications}
          onValueChange={(value) => updatePreference('notifications', value)}
        />
      </View>

      <View style={styles.switchContainer}>
        <Text>Dark Mode</Text>
        <Switch
          value={profile.preferences.darkMode}
          onValueChange={(value) => updatePreference('darkMode', value)}
        />
      </View>

      <Button
        title={loading ? 'Saving...' : 'Save Profile'}
        onPress={saveProfile}
        disabled={loading}
      />
    </View>
  );
};

// Example: Simple Todo List with Storage
const StoredTodoList = () => {
  const [todos, setTodos] = useState([]);
  const [newTodo, setNewTodo] = useState('');

  // Load todos from storage
  const loadTodos = async () => {
    const savedTodos = await StorageUtils.getArray('todos', []);
    setTodos(savedTodos);
  };

  // Save todos to storage
  const saveTodos = async (todoList) => {
    await StorageUtils.setArray('todos', todoList);
  };

  // Add new todo
  const addTodo = async () => {
    if (newTodo.trim()) {
      const newTodoItem = {
        id: Date.now().toString(),
        text: newTodo.trim(),
        completed: false,
        createdAt: new Date().toISOString(),
      };
      
      const updatedTodos = [...todos, newTodoItem];
      setTodos(updatedTodos);
      await saveTodos(updatedTodos);
      setNewTodo('');
    }
  };

  // Toggle todo completion
  const toggleTodo = async (todoId) => {
    const updatedTodos = todos.map(todo =>
      todo.id === todoId ? { ...todo, completed: !todo.completed } : todo
    );
    setTodos(updatedTodos);
    await saveTodos(updatedTodos);
  };

  // Delete todo
  const deleteTodo = async (todoId) => {
    const updatedTodos = todos.filter(todo => todo.id !== todoId);
    setTodos(updatedTodos);
    await saveTodos(updatedTodos);
  };

  useEffect(() => {
    loadTodos();
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Stored Todo List</Text>
      
      <View style={styles.addTodoContainer}>
        <TextInput
          style={styles.input}
          value={newTodo}
          onChangeText={setNewTodo}
          placeholder="Add new todo..."
          onSubmitEditing={addTodo}
        />
        <Button title="Add" onPress={addTodo} />
      </View>

      <FlatList
        data={todos}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View style={styles.todoItem}>
            <TouchableOpacity
              style={styles.todoText}
              onPress={() => toggleTodo(item.id)}
            >
              <Text style={[
                styles.todoTitle,
                item.completed && styles.completedTodo
              ]}>
                {item.text}
              </Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={styles.deleteButton}
              onPress={() => deleteTodo(item.id)}
            >
              <Text style={styles.deleteButtonText}>×</Text>
            </TouchableOpacity>
          </View>
        )}
      />
    </View>
  );
};
```

---

## Custom Storage Hooks

Reusable hooks for common storage patterns.

```jsx path=null start=null
import { useState, useEffect, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Generic storage hook
export const useAsyncStorage = (key, defaultValue = null) => {
  const [value, setValue] = useState(defaultValue);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Load value from storage
  const loadValue = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const storedValue = await AsyncStorage.getItem(key);
      if (storedValue !== null) {
        const parsedValue = JSON.parse(storedValue);
        setValue(parsedValue);
      } else {
        setValue(defaultValue);
      }
    } catch (err) {
      setError(err);
      setValue(defaultValue);
    } finally {
      setLoading(false);
    }
  }, [key, defaultValue]);

  // Save value to storage
  const storeValue = useCallback(async (newValue) => {
    try {
      setError(null);
      await AsyncStorage.setItem(key, JSON.stringify(newValue));
      setValue(newValue);
    } catch (err) {
      setError(err);
      throw err;
    }
  }, [key]);

  // Remove value from storage
  const removeValue = useCallback(async () => {
    try {
      setError(null);
      await AsyncStorage.removeItem(key);
      setValue(defaultValue);
    } catch (err) {
      setError(err);
      throw err;
    }
  }, [key, defaultValue]);

  // Load value on mount
  useEffect(() => {
    loadValue();
  }, [loadValue]);

  return {
    value,
    setValue: storeValue,
    removeValue,
    loading,
    error,
    reload: loadValue,
  };
};

// Hook for storing arrays
export const useStoredArray = (key, defaultValue = []) => {
  const { value, setValue, removeValue, loading, error, reload } = 
    useAsyncStorage(key, defaultValue);

  const addItem = useCallback(async (item) => {
    const newArray = [...(value || []), item];
    await setValue(newArray);
  }, [value, setValue]);

  const removeItem = useCallback(async (index) => {
    const newArray = (value || []).filter((_, i) => i !== index);
    await setValue(newArray);
  }, [value, setValue]);

  const updateItem = useCallback(async (index, newItem) => {
    const newArray = (value || []).map((item, i) => 
      i === index ? newItem : item
    );
    await setValue(newArray);
  }, [value, setValue]);

  const clearArray = useCallback(async () => {
    await setValue([]);
  }, [setValue]);

  return {
    items: value || [],
    setItems: setValue,
    addItem,
    removeItem,
    updateItem,
    clearArray,
    removeAll: removeValue,
    loading,
    error,
    reload,
  };
};

// Hook for user preferences
export const useUserPreferences = () => {
  const defaultPreferences = {
    theme: 'light',
    notifications: true,
    language: 'en',
    fontSize: 'medium',
  };

  const { value: preferences, setValue, loading, error } = 
    useAsyncStorage('user_preferences', defaultPreferences);

  const updatePreference = useCallback(async (key, value) => {
    const newPreferences = {
      ...preferences,
      [key]: value,
    };
    await setValue(newPreferences);
  }, [preferences, setValue]);

  const resetPreferences = useCallback(async () => {
    await setValue(defaultPreferences);
  }, [setValue]);

  return {
    preferences: preferences || defaultPreferences,
    updatePreference,
    resetPreferences,
    loading,
    error,
  };
};

// Usage examples
const PreferencesScreen = () => {
  const { preferences, updatePreference, resetPreferences, loading } = 
    useUserPreferences();

  if (loading) return <LoadingSpinner />;

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Settings</Text>
      
      <View style={styles.setting}>
        <Text>Theme</Text>
        <Picker
          selectedValue={preferences.theme}
          onValueChange={(value) => updatePreference('theme', value)}
        >
          <Picker.Item label="Light" value="light" />
          <Picker.Item label="Dark" value="dark" />
        </Picker>
      </View>

      <View style={styles.setting}>
        <Text>Notifications</Text>
        <Switch
          value={preferences.notifications}
          onValueChange={(value) => updatePreference('notifications', value)}
        />
      </View>

      <Button title="Reset to Defaults" onPress={resetPreferences} />
    </View>
  );
};

const NotesApp = () => {
  const { 
    items: notes, 
    addItem: addNote, 
    removeItem: removeNote, 
    updateItem: updateNote,
    loading 
  } = useStoredArray('notes', []);

  const [newNoteText, setNewNoteText] = useState('');

  const handleAddNote = async () => {
    if (newNoteText.trim()) {
      const newNote = {
        id: Date.now().toString(),
        text: newNoteText.trim(),
        createdAt: new Date().toISOString(),
      };
      
      await addNote(newNote);
      setNewNoteText('');
    }
  };

  if (loading) return <LoadingSpinner />;

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        value={newNoteText}
        onChangeText={setNewNoteText}
        placeholder="Write a note..."
        multiline
      />
      
      <Button title="Add Note" onPress={handleAddNote} />
      
      <FlatList
        data={notes}
        keyExtractor={(item) => item.id}
        renderItem={({ item, index }) => (
          <View style={styles.noteItem}>
            <Text style={styles.noteText}>{item.text}</Text>
            <TouchableOpacity 
              style={styles.deleteButton}
              onPress={() => removeNote(index)}
            >
              <Text>Delete</Text>
            </TouchableOpacity>
          </View>
        )}
      />
    </View>
  );
};
```

---

## Secure Storage

Handling sensitive data with encryption.

```jsx path=null start=null
// First install: npm install react-native-keychain
import * as Keychain from 'react-native-keychain';

// Secure storage utilities
const SecureStorage = {
  // Store sensitive data (like tokens, passwords)
  setSecureValue: async (key, value) => {
    try {
      await Keychain.setInternetCredentials(key, key, value);
      return true;
    } catch (error) {
      console.error('Failed to store secure value:', error);
      return false;
    }
  },

  // Get sensitive data
  getSecureValue: async (key) => {
    try {
      const credentials = await Keychain.getInternetCredentials(key);
      if (credentials && credentials.password) {
        return credentials.password;
      }
      return null;
    } catch (error) {
      console.error('Failed to get secure value:', error);
      return null;
    }
  },

  // Remove sensitive data
  removeSecureValue: async (key) => {
    try {
      await Keychain.resetInternetCredentials(key);
      return true;
    } catch (error) {
      console.error('Failed to remove secure value:', error);
      return false;
    }
  },

  // Check if secure value exists
  hasSecureValue: async (key) => {
    try {
      const credentials = await Keychain.getInternetCredentials(key);
      return credentials !== false;
    } catch (error) {
      console.error('Failed to check secure value:', error);
      return false;
    }
  },
};

// Secure authentication hook
export const useSecureAuth = () => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [loading, setLoading] = useState(true);

  // Check if user is already authenticated
  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      setLoading(true);
      const token = await SecureStorage.getSecureValue('auth_token');
      setIsAuthenticated(!!token);
    } catch (error) {
      console.error('Auth check failed:', error);
      setIsAuthenticated(false);
    } finally {
      setLoading(false);
    }
  };

  // Login and store token securely
  const login = async (email, password) => {
    try {
      // Simulate API login
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      const data = await response.json();
      
      if (response.ok && data.token) {
        // Store token securely
        await SecureStorage.setSecureValue('auth_token', data.token);
        await SecureStorage.setSecureValue('refresh_token', data.refreshToken);
        
        setIsAuthenticated(true);
        return { success: true };
      } else {
        throw new Error(data.message || 'Login failed');
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  // Logout and clear secure storage
  const logout = async () => {
    try {
      await SecureStorage.removeSecureValue('auth_token');
      await SecureStorage.removeSecureValue('refresh_token');
      setIsAuthenticated(false);
    } catch (error) {
      console.error('Logout failed:', error);
    }
  };

  // Get stored auth token
  const getAuthToken = async () => {
    return await SecureStorage.getSecureValue('auth_token');
  };

  return {
    isAuthenticated,
    login,
    logout,
    getAuthToken,
    loading,
  };
};

// Usage example
const LoginScreen = () => {
  const { login, loading } = useSecureAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = async () => {
    const result = await login(email, password);
    if (result.success) {
      Alert.alert('Success', 'Logged in successfully');
    } else {
      Alert.alert('Error', result.error);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        value={email}
        onChangeText={setEmail}
        placeholder="Email"
        keyboardType="email-address"
        autoCapitalize="none"
      />
      
      <TextInput
        style={styles.input}
        value={password}
        onChangeText={setPassword}
        placeholder="Password"
        secureTextEntry
      />
      
      <Button
        title={loading ? 'Logging in...' : 'Login'}
        onPress={handleLogin}
        disabled={loading}
      />
    </View>
  );
};
```

---

## Database Solutions

For more complex storage needs, consider SQLite or Realm.

```jsx path=null start=null
// SQLite with react-native-sqlite-storage
// First install: npm install react-native-sqlite-storage

import SQLite from 'react-native-sqlite-storage';

// Database setup
const initDatabase = () => {
  return new Promise((resolve, reject) => {
    const db = SQLite.openDatabase(
      { name: 'app.db', location: 'default' },
      () => {
        console.log('Database opened successfully');
        
        // Create tables
        db.transaction((tx) => {
          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS users (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL,
              email TEXT UNIQUE NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );`,
            [],
            () => console.log('Users table created'),
            (_, error) => console.error('Failed to create users table:', error)
          );

          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS notes (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              user_id INTEGER,
              title TEXT NOT NULL,
              content TEXT,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (user_id) REFERENCES users (id)
            );`,
            [],
            () => console.log('Notes table created'),
            (_, error) => console.error('Failed to create notes table:', error)
          );
        });

        resolve(db);
      },
      (error) => {
        console.error('Failed to open database:', error);
        reject(error);
      }
    );
  });
};

// Database operations
const DatabaseService = {
  // Insert user
  insertUser: (db, name, email) => {
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          'INSERT INTO users (name, email) VALUES (?, ?)',
          [name, email],
          (_, result) => resolve(result.insertId),
          (_, error) => reject(error)
        );
      });
    });
  },

  // Get all users
  getUsers: (db) => {
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          'SELECT * FROM users ORDER BY created_at DESC',
          [],
          (_, result) => {
            const users = [];
            for (let i = 0; i < result.rows.length; i++) {
              users.push(result.rows.item(i));
            }
            resolve(users);
          },
          (_, error) => reject(error)
        );
      });
    });
  },

  // Insert note
  insertNote: (db, userId, title, content) => {
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          'INSERT INTO notes (user_id, title, content) VALUES (?, ?, ?)',
          [userId, title, content],
          (_, result) => resolve(result.insertId),
          (_, error) => reject(error)
        );
      });
    });
  },

  // Get notes by user
  getNotesByUser: (db, userId) => {
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          `SELECT n.*, u.name as user_name 
           FROM notes n 
           JOIN users u ON n.user_id = u.id 
           WHERE n.user_id = ? 
           ORDER BY n.created_at DESC`,
          [userId],
          (_, result) => {
            const notes = [];
            for (let i = 0; i < result.rows.length; i++) {
              notes.push(result.rows.item(i));
            }
            resolve(notes);
          },
          (_, error) => reject(error)
        );
      });
    });
  },
};

// Usage example
const DatabaseExample = () => {
  const [db, setDb] = useState(null);
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setupDatabase();
  }, []);

  const setupDatabase = async () => {
    try {
      const database = await initDatabase();
      setDb(database);
      await loadUsers(database);
    } catch (error) {
      Alert.alert('Error', 'Failed to setup database');
    } finally {
      setLoading(false);
    }
  };

  const loadUsers = async (database = db) => {
    try {
      const userList = await DatabaseService.getUsers(database);
      setUsers(userList);
    } catch (error) {
      Alert.alert('Error', 'Failed to load users');
    }
  };

  const addUser = async (name, email) => {
    try {
      await DatabaseService.insertUser(db, name, email);
      await loadUsers();
      Alert.alert('Success', 'User added successfully');
    } catch (error) {
      Alert.alert('Error', 'Failed to add user');
    }
  };

  if (loading) {
    return <LoadingSpinner />;
  }

  return (
    <View style={styles.container}>
      {/* Your UI components here */}
    </View>
  );
};
```

---

## 💡 Key Takeaways

1. **AsyncStorage** is perfect for simple key-value storage
2. **Always handle errors** in storage operations
3. **JSON stringify/parse** for complex data structures
4. **Custom hooks** make storage logic reusable
5. **Secure storage** for sensitive data like tokens
6. **SQLite** for complex relational data
7. **Consider performance** with large datasets
8. **Implement proper error handling** and fallbacks

---

## 🔗 Related Notes
- [[10.Data Fetching]] - Caching fetched data
- [[9.Local State Management]] - Managing stored data in state
- [[14.Performance Optimization]] - Storage performance tips

## 📚 Next Steps
1. Practice implementing different storage patterns
2. Set up secure storage for sensitive data
3. Consider database solutions for complex apps
4. Move on to [[12.Platform APIs]]

---
*Tags: #react-native #storage #asyncstorage #database #persistence #stage-3 #security*
