---
title: "Local State Management"
description: "Advanced state management patterns using React hooks and Context API"
navigation:
  icon: i-lucide-house
---

# Local State Management

#react-native #state #hooks #context #reducer #stage-3

> Advanced state management patterns using React hooks and Context API

## 🔗 Navigation
← [[8.Images and Media]] | → [[10.Data Fetching]]

---

## Advanced useState Patterns

Beyond basic state management with sophisticated patterns.

```jsx path=null start=null
import React, { useState, useCallback } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';

// Complex state with object updates
const UserProfile = () => {
  const [user, setUser] = useState({
    personal: {
      firstName: '',
      lastName: '',
      email: '',
    },
    preferences: {
      notifications: true,
      theme: 'light',
      language: 'en',
    },
    settings: {
      privacy: 'public',
      twoFactor: false,
    },
  });

  // Safe nested state updates
  const updatePersonalInfo = useCallback((field, value) => {
    setUser(prevUser => ({
      ...prevUser,
      personal: {
        ...prevUser.personal,
        [field]: value,
      },
    }));
  }, []);

  const updatePreferences = useCallback((preference, value) => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        [preference]: value,
      },
    }));
  }, []);

  const resetUser = useCallback(() => {
    setUser({
      personal: { firstName: '', lastName: '', email: '' },
      preferences: { notifications: true, theme: 'light', language: 'en' },
      settings: { privacy: 'public', twoFactor: false },
    });
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>User Profile</Text>
      
      <TextInput
        style={styles.input}
        placeholder="First Name"
        value={user.personal.firstName}
        onChangeText={(text) => updatePersonalInfo('firstName', text)}
      />
      
      <TextInput
        style={styles.input}
        placeholder="Last Name"
        value={user.personal.lastName}
        onChangeText={(text) => updatePersonalInfo('lastName', text)}
      />
      
      <Button
        title="Toggle Notifications"
        onPress={() => updatePreferences('notifications', !user.preferences.notifications)}
      />
      
      <Button title="Reset Profile" onPress={resetUser} />
      
      <Text style={styles.debug}>
        {JSON.stringify(user, null, 2)}
      </Text>
    </View>
  );
};
```

---

## useReducer for Complex State

When useState becomes unwieldy, useReducer provides better structure.

```jsx path=null start=null
import React, { useReducer, useCallback } from 'react';

// Action types
const ACTIONS = {
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  DELETE_TODO: 'DELETE_TODO',
  EDIT_TODO: 'EDIT_TODO',
  SET_FILTER: 'SET_FILTER',
  CLEAR_COMPLETED: 'CLEAR_COMPLETED',
};

// Reducer function
const todoReducer = (state, action) => {
  switch (action.type) {
    case ACTIONS.ADD_TODO:
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now().toString(),
            text: action.payload.text,
            completed: false,
            createdAt: new Date().toISOString(),
          },
        ],
        nextId: state.nextId + 1,
      };

    case ACTIONS.TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };

    case ACTIONS.DELETE_TODO:
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload.id),
      };

    case ACTIONS.EDIT_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, text: action.payload.text }
            : todo
        ),
      };

    case ACTIONS.SET_FILTER:
      return {
        ...state,
        filter: action.payload.filter,
      };

    case ACTIONS.CLEAR_COMPLETED:
      return {
        ...state,
        todos: state.todos.filter(todo => !todo.completed),
      };

    default:
      return state;
  }
};

// Initial state
const initialState = {
  todos: [],
  filter: 'all', // 'all', 'active', 'completed'
  nextId: 1,
};

const TodoApp = () => {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  const [newTodoText, setNewTodoText] = useState('');

  // Action creators
  const addTodo = useCallback((text) => {
    if (text.trim()) {
      dispatch({
        type: ACTIONS.ADD_TODO,
        payload: { text: text.trim() },
      });
    }
  }, []);

  const toggleTodo = useCallback((id) => {
    dispatch({
      type: ACTIONS.TOGGLE_TODO,
      payload: { id },
    });
  }, []);

  const deleteTodo = useCallback((id) => {
    dispatch({
      type: ACTIONS.DELETE_TODO,
      payload: { id },
    });
  }, []);

  const setFilter = useCallback((filter) => {
    dispatch({
      type: ACTIONS.SET_FILTER,
      payload: { filter },
    });
  }, []);

  const clearCompleted = useCallback(() => {
    dispatch({ type: ACTIONS.CLEAR_COMPLETED });
  }, []);

  // Computed values
  const filteredTodos = useMemo(() => {
    switch (state.filter) {
      case 'active':
        return state.todos.filter(todo => !todo.completed);
      case 'completed':
        return state.todos.filter(todo => todo.completed);
      default:
        return state.todos;
    }
  }, [state.todos, state.filter]);

  const handleAddTodo = () => {
    addTodo(newTodoText);
    setNewTodoText('');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Todo App</Text>
      
      {/* Add new todo */}
      <View style={styles.addTodoContainer}>
        <TextInput
          style={styles.input}
          value={newTodoText}
          onChangeText={setNewTodoText}
          placeholder="Add new todo..."
          onSubmitEditing={handleAddTodo}
        />
        <Button title="Add" onPress={handleAddTodo} />
      </View>

      {/* Filter buttons */}
      <View style={styles.filterContainer}>
        {['all', 'active', 'completed'].map(filter => (
          <Button
            key={filter}
            title={filter.charAt(0).toUpperCase() + filter.slice(1)}
            onPress={() => setFilter(filter)}
            color={state.filter === filter ? '#007AFF' : '#999'}
          />
        ))}
      </View>

      {/* Todo list */}
      <FlatList
        data={filteredTodos}
        keyExtractor={item => item.id}
        renderItem={({ item }) => (
          <TodoItem
            todo={item}
            onToggle={toggleTodo}
            onDelete={deleteTodo}
          />
        )}
        style={styles.todoList}
      />

      {/* Clear completed button */}
      {state.todos.some(todo => todo.completed) && (
        <Button
          title="Clear Completed"
          onPress={clearCompleted}
          color="#ff6b6b"
        />
      )}
    </View>
  );
};

const TodoItem = ({ todo, onToggle, onDelete }) => (
  <View style={styles.todoItem}>
    <TouchableOpacity
      style={styles.todoText}
      onPress={() => onToggle(todo.id)}
    >
      <Text style={[
        styles.todoTitle,
        todo.completed && styles.completedTodo
      ]}>
        {todo.text}
      </Text>
    </TouchableOpacity>
    
    <TouchableOpacity
      style={styles.deleteButton}
      onPress={() => onDelete(todo.id)}
    >
      <Text style={styles.deleteButtonText}>×</Text>
    </TouchableOpacity>
  </View>
);
```

---

## Context API for Global State

Share state across components without prop drilling.

```jsx path=null start=null
import React, { createContext, useContext, useReducer, useCallback } from 'react';

// Auth Context
const AuthContext = createContext();

// Auth actions
const AUTH_ACTIONS = {
  LOGIN_START: 'LOGIN_START',
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGIN_FAILURE: 'LOGIN_FAILURE',
  LOGOUT: 'LOGOUT',
  UPDATE_USER: 'UPDATE_USER',
};

// Auth reducer
const authReducer = (state, action) => {
  switch (action.type) {
    case AUTH_ACTIONS.LOGIN_START:
      return {
        ...state,
        loading: true,
        error: null,
      };

    case AUTH_ACTIONS.LOGIN_SUCCESS:
      return {
        ...state,
        loading: false,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        error: null,
      };

    case AUTH_ACTIONS.LOGIN_FAILURE:
      return {
        ...state,
        loading: false,
        user: null,
        token: null,
        isAuthenticated: false,
        error: action.payload.error,
      };

    case AUTH_ACTIONS.LOGOUT:
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        loading: false,
        error: null,
      };

    case AUTH_ACTIONS.UPDATE_USER:
      return {
        ...state,
        user: {
          ...state.user,
          ...action.payload.updates,
        },
      };

    default:
      return state;
  }
};

// Initial auth state
const initialAuthState = {
  user: null,
  token: null,
  isAuthenticated: false,
  loading: false,
  error: null,
};

// Auth Provider component
export const AuthProvider = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, initialAuthState);

  // Action creators
  const login = useCallback(async (email, password) => {
    dispatch({ type: AUTH_ACTIONS.LOGIN_START });

    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      if (email === 'test@example.com' && password === 'password') {
        const userData = {
          user: {
            id: '1',
            name: 'John Doe',
            email,
          },
          token: 'fake-jwt-token',
        };

        dispatch({
          type: AUTH_ACTIONS.LOGIN_SUCCESS,
          payload: userData,
        });

        return { success: true };
      } else {
        throw new Error('Invalid credentials');
      }
    } catch (error) {
      dispatch({
        type: AUTH_ACTIONS.LOGIN_FAILURE,
        payload: { error: error.message },
      });
      return { success: false, error: error.message };
    }
  }, []);

  const logout = useCallback(() => {
    dispatch({ type: AUTH_ACTIONS.LOGOUT });
  }, []);

  const updateUser = useCallback((updates) => {
    dispatch({
      type: AUTH_ACTIONS.UPDATE_USER,
      payload: { updates },
    });
  }, []);

  const contextValue = {
    ...state,
    login,
    logout,
    updateUser,
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

// Custom hook to use auth context
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

// Usage in components
const LoginScreen = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const { login, loading, error } = useAuth();

  const handleLogin = async () => {
    const result = await login(email, password);
    if (result.success) {
      // Navigate to main app or show success
      console.log('Login successful');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Login</Text>
      
      {error && (
        <Text style={styles.error}>{error}</Text>
      )}
      
      <TextInput
        style={styles.input}
        value={email}
        onChangeText={setEmail}
        placeholder="Email"
        keyboardType="email-address"
        autoCapitalize="none"
      />
      
      <TextInput
        style={styles.input}
        value={password}
        onChangeText={setPassword}
        placeholder="Password"
        secureTextEntry
      />
      
      <Button
        title={loading ? 'Logging in...' : 'Login'}
        onPress={handleLogin}
        disabled={loading}
      />
    </View>
  );
};

const ProfileScreen = () => {
  const { user, updateUser, logout } = useAuth();

  const handleUpdateName = () => {
    updateUser({ name: 'Updated Name' });
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Profile</Text>
      <Text>Name: {user?.name}</Text>
      <Text>Email: {user?.email}</Text>
      
      <Button title="Update Name" onPress={handleUpdateName} />
      <Button title="Logout" onPress={logout} />
    </View>
  );
};

// App wrapper
const App = () => {
  return (
    <AuthProvider>
      <AppNavigator />
    </AuthProvider>
  );
};
```

---

## Custom Hooks for State Logic

Reusable state logic with custom hooks.

```jsx path=null start=null
import { useState, useEffect, useCallback, useRef } from 'react';

// Custom hook for form handling
export const useForm = (initialValues, validationRules) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const validateField = useCallback((name, value) => {
    const rules = validationRules[name];
    if (!rules) return '';

    for (const rule of rules) {
      const error = rule(value, values);
      if (error) return error;
    }
    return '';
  }, [validationRules, values]);

  const setValue = useCallback((name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    if (touched[name]) {
      const error = validateField(name, value);
      setErrors(prev => ({ ...prev, [name]: error }));
    }
  }, [touched, validateField]);

  const setFieldTouched = useCallback((name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
    const error = validateField(name, values[name]);
    setErrors(prev => ({ ...prev, [name]: error }));
  }, [validateField, values]);

  const validateAll = useCallback(() => {
    const newErrors = {};
    let isValid = true;

    Object.keys(validationRules).forEach(name => {
      const error = validateField(name, values[name]);
      if (error) {
        newErrors[name] = error;
        isValid = false;
      }
    });

    setErrors(newErrors);
    return isValid;
  }, [validationRules, validateField, values]);

  const handleSubmit = useCallback(async (onSubmit) => {
    setIsSubmitting(true);
    const isValid = validateAll();
    
    if (isValid) {
      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Form submission error:', error);
      }
    }
    
    setIsSubmitting(false);
  }, [validateAll, values]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    setValue,
    setFieldTouched,
    handleSubmit,
    reset,
  };
};

// Custom hook for async data fetching
export const useAsyncData = (asyncFunction, dependencies = []) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const cancelRef = useRef(false);

  const execute = useCallback(async (...args) => {
    try {
      setLoading(true);
      setError(null);
      cancelRef.current = false;
      
      const result = await asyncFunction(...args);
      
      if (!cancelRef.current) {
        setData(result);
      }
    } catch (err) {
      if (!cancelRef.current) {
        setError(err.message);
      }
    } finally {
      if (!cancelRef.current) {
        setLoading(false);
      }
    }
  }, [asyncFunction]);

  useEffect(() => {
    execute();
    
    return () => {
      cancelRef.current = true;
    };
  }, dependencies);

  const refetch = useCallback(() => {
    execute();
  }, [execute]);

  return { data, loading, error, refetch };
};

// Custom hook for toggle state
export const useToggle = (initialValue = false) => {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(prev => !prev);
  }, []);
  
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);
  
  return [value, toggle, setTrue, setFalse];
};

// Custom hook for counter
export const useCounter = (initialValue = 0, step = 1) => {
  const [count, setCount] = useState(initialValue);
  
  const increment = useCallback(() => {
    setCount(prev => prev + step);
  }, [step]);
  
  const decrement = useCallback(() => {
    setCount(prev => prev - step);
  }, [step]);
  
  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);
  
  const setValue = useCallback((value) => {
    setCount(value);
  }, []);
  
  return {
    count,
    increment,
    decrement,
    reset,
    setValue,
  };
};

// Usage examples
const FormExample = () => {
  const { values, errors, touched, setValue, setFieldTouched, handleSubmit } = useForm(
    { email: '', password: '' },
    {
      email: [(value) => !value ? 'Email required' : ''],
      password: [(value) => !value ? 'Password required' : ''],
    }
  );

  const onSubmit = async (formData) => {
    console.log('Submitting:', formData);
    // API call here
  };

  return (
    <View>
      <TextInput
        value={values.email}
        onChangeText={(text) => setValue('email', text)}
        onBlur={() => setFieldTouched('email')}
        placeholder="Email"
      />
      {errors.email && touched.email && (
        <Text style={styles.error}>{errors.email}</Text>
      )}
      
      <Button
        title="Submit"
        onPress={() => handleSubmit(onSubmit)}
      />
    </View>
  );
};

const CounterExample = () => {
  const { count, increment, decrement, reset } = useCounter(0);
  
  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="+" onPress={increment} />
      <Button title="-" onPress={decrement} />
      <Button title="Reset" onPress={reset} />
    </View>
  );
};
```

---

## 💡 Key Takeaways

1. **useReducer** for complex state logic with multiple related updates
2. **Context API** prevents prop drilling and provides global state access
3. **Custom hooks** encapsulate and reuse stateful logic
4. **Always use functional updates** when state depends on previous state
5. **Memoize callbacks** and computed values to prevent unnecessary re-renders
6. **Structure reducers** with clear action types and consistent patterns
7. **Custom hooks** should follow the `use` naming convention

---

## 🔗 Related Notes
- [[React Basics for React Native]] - Foundation hooks like useState
- [[10.Data Fetching]] - Managing server state
- [[14.Performance Optimization]] - Optimizing state updates

## 📚 Next Steps
1. Practice building complex state with useReducer
2. Implement Context API for app-wide state
3. Create reusable custom hooks
4. Move on to [[10.Data Fetching]]

---
*Tags: #react-native #state #hooks #context #reducer #stage-3 #custom-hooks*
