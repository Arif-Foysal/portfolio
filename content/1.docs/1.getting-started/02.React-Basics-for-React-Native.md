---
title: "React Basics for React Native"
description: "Essential React concepts that form the foundation of React Native development"
navigation:
  icon: i-lucide-house
---

# React Basics for React Native

#react-native #react #fundamentals #stage-1

> Essential React concepts that form the foundation of React Native development

## 🔗 Navigation
← [[1.React Native Learning Path]] | → [[3.Core React Native Components]]

---

## JSX (JavaScript XML)

JSX allows you to write HTML-like syntax in JavaScript. In React Native, JSX elements become native components.

```jsx path=null start=null
// React Native JSX
const MyComponent = () => {
  return (
    <View>
      <Text>Hello, React Native!</Text>
    </View>
  );
};
```

### Key JSX Rules
- **Single Parent**: Components must return a single parent element
- **Self-closing tags**: `<Image />` not `<Image>`
- **CamelCase props**: `onChangeText`, `backgroundColor`
- **JavaScript expressions**: Use `{}` for dynamic content

```jsx path=null start=null
const name = 'Developer';
return (
  <View>
    <Text>Welcome, {name}!</Text>
    <Text>{2 + 3}</Text>
  </View>
);
```

---

## Functional Components

Modern React Native uses functional components with hooks.

```jsx path=null start=null
import React from 'react';
import { View, Text } from 'react-native';

const WelcomeScreen = () => {
  return (
    <View>
      <Text>Welcome to React Native!</Text>
    </View>
  );
};

export default WelcomeScreen;
```

### Component Best Practices
- Use **PascalCase** for component names
- Keep components **small and focused**
- Use **arrow functions** for modern syntax
- Always **export default** your main component

---

## Props (Properties)

Props pass data from parent to child components.

```jsx path=null start=null
// Parent component
const App = () => {
  return (
    <View>
      <UserCard name="John Doe" age={30} isOnline={true} />
    </View>
  );
};

// Child component
const UserCard = ({ name, age, isOnline }) => {
  return (
    <View>
      <Text>Name: {name}</Text>
      <Text>Age: {age}</Text>
      <Text>Status: {isOnline ? 'Online' : 'Offline'}</Text>
    </View>
  );
};
```

### Props Patterns
```jsx path=null start=null
// Destructuring props
const Button = ({ title, onPress, disabled = false }) => {
  // ...
};

// Props with default values
const Avatar = ({ size = 50, source }) => {
  // ...
};

// Spreading props
const CustomButton = (props) => {
  return <Pressable {...props} />;
};
```

---

## State with useState Hook

State manages data that changes over time within a component.

```jsx path=null start=null
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';

const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  const decrement = () => {
    setCount(prevCount => prevCount - 1); // Preferred for updates
  };

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="+" onPress={increment} />
      <Button title="-" onPress={decrement} />
    </View>
  );
};
```

### State Best Practices
- **Don't mutate state directly**: Always use setter function
- **Use functional updates**: `setCount(prev => prev + 1)`
- **Initialize with appropriate type**: `useState('')`, `useState([])`
- **Keep state minimal**: Only store what needs to trigger re-renders

### Complex State Example
```jsx path=null start=null
const UserProfile = () => {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0
  });

  const updateName = (newName) => {
    setUser(prevUser => ({
      ...prevUser,
      name: newName
    }));
  };

  return (
    <View>
      <Text>Name: {user.name}</Text>
      {/* Form inputs would go here */}
    </View>
  );
};
```

---

## useEffect Hook

Handle side effects like API calls, subscriptions, or cleanup.

```jsx path=null start=null
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';

const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Run once when component mounts
  useEffect(() => {
    console.log('Component mounted');
    return () => {
      console.log('Component will unmount');
    };
  }, []); // Empty dependency array

  // Run when userId changes
  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchUser();
    }
  }, [userId]); // Runs when userId changes

  if (loading) {
    return <Text>Loading...</Text>;
  }

  return (
    <View>
      <Text>Name: {user?.name}</Text>
      <Text>Email: {user?.email}</Text>
    </View>
  );
};
```

### useEffect Patterns

#### 1. Component Mount/Unmount
```jsx path=null start=null
useEffect(() => {
  // Setup
  const subscription = subscribeTo(something);
  
  // Cleanup
  return () => {
    subscription.unsubscribe();
  };
}, []);
```

#### 2. Conditional Effects
```jsx path=null start=null
useEffect(() => {
  if (isLoggedIn) {
    fetchUserData();
  }
}, [isLoggedIn]);
```

#### 3. Multiple Dependencies
```jsx path=null start=null
useEffect(() => {
  updateChart(data, filters, sortBy);
}, [data, filters, sortBy]);
```

---

## Common Hooks Summary

| Hook | Purpose | Example |
|------|---------|---------|
| `useState` | Manage component state | `const [value, setValue] = useState('')` |
| `useEffect` | Handle side effects | `useEffect(() => {}, [dependency])` |
| `useContext` | Access context values | `const value = useContext(MyContext)` |
| `useReducer` | Complex state logic | `const [state, dispatch] = useReducer(reducer, initial)` |
| `useMemo` | Memoize expensive calculations | `const result = useMemo(() => calculate(), [deps])` |
| `useCallback` | Memoize function references | `const fn = useCallback(() => {}, [deps])` |

---

## 💡 Key Takeaways

1. **JSX** translates to native components in React Native
2. **Functional components** with **hooks** are the modern approach
3. **Props** flow down from parent to child (one-way data flow)
4. **State** manages component data that changes over time
5. **useEffect** handles side effects and lifecycle events
6. Always use **dependency arrays** correctly in useEffect

---

## 🔗 Related Notes
- [[3.Core React Native Components]] - Learn the building blocks
- [[4.React Native Styling]] - Style your components
- [[9.Local State Management]] - Advanced state patterns

## 📚 Next Steps
1. Practice creating functional components
2. Experiment with useState for different data types
3. Use useEffect for data fetching
4. Move on to [[3.Core React Native Components]]

---
*Tags: #react-native #react #fundamentals #stage-1 #jsx #hooks #state #props*
