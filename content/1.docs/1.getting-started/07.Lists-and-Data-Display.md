---
title: "Lists and Data Display"
description: "Master efficient list rendering and data display patterns in React Native"
navigation:
  icon: i-lucide-house
---

# Lists and Data Display

#react-native #lists #flatlist #sectionlist #data #stage-2

> Master efficient list rendering and data display patterns in React Native

## 🔗 Navigation
← [[6.Handling User Input]] | → [[8.Images and Media]]

---

## FlatList Fundamentals

FlatList is the go-to component for rendering large lists efficiently.

```jsx path=null start=null
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  RefreshControl,
} from 'react-native';

const BasicFlatList = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  // Sample data
  const generateData = (count = 50) => {
    return Array.from({ length: count }, (_, index) => ({
      id: `item-${index}`,
      title: `Item ${index + 1}`,
      subtitle: `This is the subtitle for item ${index + 1}`,
      value: Math.floor(Math.random() * 100),
    }));
  };

  useEffect(() => {
    // Simulate API call
    const loadData = async () => {
      await new Promise(resolve => setTimeout(resolve, 1000));
      setData(generateData());
      setLoading(false);
    };

    loadData();
  }, []);

  const renderItem = ({ item, index }) => (
    <View style={[styles.listItem, index % 2 === 0 && styles.evenItem]}>
      <View style={styles.itemContent}>
        <Text style={styles.itemTitle}>{item.title}</Text>
        <Text style={styles.itemSubtitle}>{item.subtitle}</Text>
      </View>
      <View style={styles.itemValue}>
        <Text style={styles.valueText}>{item.value}</Text>
      </View>
    </View>
  );

  const keyExtractor = (item) => item.id;

  const handleRefresh = async () => {
    setRefreshing(true);
    // Simulate refresh delay
    await new Promise(resolve => setTimeout(resolve, 1500));
    setData(generateData());
    setRefreshing(false);
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007AFF" />
        <Text style={styles.loadingText}>Loading...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={data}
        renderItem={renderItem}
        keyExtractor={keyExtractor}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#007AFF']} // Android
            tintColor="#007AFF" // iOS
          />
        }
        ItemSeparatorComponent={() => <View style={styles.separator} />}
        ListHeaderComponent={() => (
          <View style={styles.header}>
            <Text style={styles.headerText}>My List ({data.length} items)</Text>
          </View>
        )}
        ListFooterComponent={() => (
          <View style={styles.footer}>
            <Text style={styles.footerText}>End of list</Text>
          </View>
        )}
        ListEmptyComponent={() => (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>No items found</Text>
          </View>
        )}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 20 }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  listItem: {
    flexDirection: 'row',
    padding: 15,
    backgroundColor: '#fff',
    alignItems: 'center',
  },
  evenItem: {
    backgroundColor: '#f9f9f9',
  },
  itemContent: {
    flex: 1,
  },
  itemTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  itemSubtitle: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  itemValue: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 15,
  },
  valueText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: 'bold',
  },
  separator: {
    height: 1,
    backgroundColor: '#e0e0e0',
  },
  header: {
    padding: 20,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  headerText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  footer: {
    padding: 20,
    alignItems: 'center',
  },
  footerText: {
    fontSize: 14,
    color: '#999',
  },
  emptyContainer: {
    padding: 40,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: '#999',
  },
});
```

---

## FlatList Performance Optimization

Essential optimizations for smooth scrolling with large datasets.

```jsx path=null start=null
import React, { useState, useCallback, useMemo } from 'react';
import { FlatList, View, Text, Image, StyleSheet } from 'react-native';

const OptimizedFlatList = ({ data }) => {
  const [viewableItems, setViewableItems] = useState([]);

  // Memoized item component to prevent unnecessary re-renders
  const ListItem = React.memo(({ item, index, isVisible }) => {
    return (
      <View style={[styles.item, !isVisible && styles.hiddenItem]}>
        <Image
          source={{ uri: item.imageUrl }}
          style={styles.itemImage}
          // Only load images for visible items
          {...(!isVisible && { source: null })}
        />
        <View style={styles.itemContent}>
          <Text style={styles.itemTitle}>{item.title}</Text>
          <Text style={styles.itemSubtitle} numberOfLines={2}>
            {item.description}
          </Text>
        </View>
      </View>
    );
  });

  // Memoized render function
  const renderItem = useCallback(({ item, index }) => {
    const isVisible = viewableItems.some(viewable => viewable.key === item.id);
    
    return (
      <ListItem 
        item={item} 
        index={index} 
        isVisible={isVisible}
      />
    );
  }, [viewableItems]);

  // Memoized key extractor
  const keyExtractor = useCallback((item) => item.id, []);

  // Fixed item layout for better performance (if items have consistent height)
  const getItemLayout = useCallback((data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index,
  }), []);

  // Viewable items change handler
  const onViewableItemsChanged = useCallback(({ viewableItems: visible }) => {
    setViewableItems(visible);
  }, []);

  // Viewability config
  const viewabilityConfig = useMemo(() => ({
    itemVisiblePercentThreshold: 50, // Item is visible when 50% is shown
    minimumViewTime: 300, // Wait 300ms before considering item viewable
  }), []);

  return (
    <FlatList
      data={data}
      renderItem={renderItem}
      keyExtractor={keyExtractor}
      
      // Performance optimizations
      removeClippedSubviews={true} // Remove off-screen items from native view hierarchy
      windowSize={10} // Number of screens worth of items to render
      maxToRenderPerBatch={10} // Max items rendered per batch
      updateCellsBatchingPeriod={50} // Delay between batches (ms)
      initialNumToRender={10} // Items to render initially
      
      // Use if you have consistent item heights
      getItemLayout={getItemLayout}
      
      // Viewability tracking
      onViewableItemsChanged={onViewableItemsChanged}
      viewabilityConfig={viewabilityConfig}
      
      // Other props
      showsVerticalScrollIndicator={false}
    />
  );
};

const ITEM_HEIGHT = 100;

const styles = StyleSheet.create({
  item: {
    height: ITEM_HEIGHT,
    flexDirection: 'row',
    padding: 10,
    backgroundColor: '#fff',
    marginBottom: 1,
  },
  hiddenItem: {
    opacity: 0.5, // Visual indicator for non-visible items (debugging)
  },
  itemImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
    backgroundColor: '#f0f0f0',
  },
  itemContent: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  itemTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  itemSubtitle: {
    fontSize: 14,
    color: '#666',
  },
});
```

---

## Infinite Scroll & Load More

Implement pagination and infinite scrolling patterns.

```jsx path=null start=null
import React, { useState, useCallback, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  ActivityIndicator,
  StyleSheet,
  Alert,
} from 'react-native';

const InfiniteScrollList = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [hasMoreData, setHasMoreData] = useState(true);
  const [page, setPage] = useState(1);
  const [error, setError] = useState(null);

  const PAGE_SIZE = 20;

  // Simulated API call
  const fetchData = async (pageNumber = 1, reset = false) => {
    try {
      // Simulate network delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Simulate no more data after page 5
      if (pageNumber > 5) {
        return { items: [], hasMore: false };
      }

      const startIndex = (pageNumber - 1) * PAGE_SIZE;
      const newItems = Array.from({ length: PAGE_SIZE }, (_, index) => ({
        id: `item-${startIndex + index}`,
        title: `Item ${startIndex + index + 1}`,
        subtitle: `Page ${pageNumber} - Item ${index + 1}`,
        timestamp: new Date().toLocaleTimeString(),
      }));

      return {
        items: newItems,
        hasMore: pageNumber < 5, // Simulate finite data
      };
    } catch (err) {
      throw new Error('Failed to load data');
    }
  };

  // Initial load
  useEffect(() => {
    loadInitialData();
  }, []);

  const loadInitialData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await fetchData(1);
      setData(result.items);
      setHasMoreData(result.hasMore);
      setPage(1);
    } catch (err) {
      setError(err.message);
      Alert.alert('Error', err.message);
    } finally {
      setLoading(false);
    }
  };

  const loadMoreData = async () => {
    if (loadingMore || !hasMoreData) return;

    setLoadingMore(true);
    setError(null);

    try {
      const nextPage = page + 1;
      const result = await fetchData(nextPage);
      
      setData(prevData => [...prevData, ...result.items]);
      setHasMoreData(result.hasMore);
      setPage(nextPage);
    } catch (err) {
      setError(err.message);
      Alert.alert('Error', err.message);
    } finally {
      setLoadingMore(false);
    }
  };

  const onEndReached = useCallback(() => {
    loadMoreData();
  }, [loadMoreData]);

  const renderItem = ({ item, index }) => (
    <View style={styles.item}>
      <Text style={styles.itemTitle}>{item.title}</Text>
      <Text style={styles.itemSubtitle}>{item.subtitle}</Text>
      <Text style={styles.itemTimestamp}>Loaded at: {item.timestamp}</Text>
    </View>
  );

  const renderFooter = () => {
    if (!hasMoreData && data.length > 0) {
      return (
        <View style={styles.footerContainer}>
          <Text style={styles.footerText}>No more items to load</Text>
        </View>
      );
    }

    if (loadingMore) {
      return (
        <View style={styles.footerContainer}>
          <ActivityIndicator size="small" color="#007AFF" />
          <Text style={styles.footerText}>Loading more...</Text>
        </View>
      );
    }

    return null;
  };

  const keyExtractor = useCallback((item) => item.id, []);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007AFF" />
        <Text style={styles.loadingText}>Loading data...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={data}
        renderItem={renderItem}
        keyExtractor={keyExtractor}
        onEndReached={onEndReached}
        onEndReachedThreshold={0.1} // Trigger when 90% scrolled
        ListFooterComponent={renderFooter}
        refreshing={loading}
        onRefresh={loadInitialData}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContainer}
      />
      
      {/* Error state */}
      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  listContainer: {
    padding: 10,
  },
  item: {
    backgroundColor: '#fff',
    padding: 15,
    marginBottom: 10,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  itemTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  itemSubtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  itemTimestamp: {
    fontSize: 12,
    color: '#999',
  },
  footerContainer: {
    padding: 20,
    alignItems: 'center',
  },
  footerText: {
    fontSize: 14,
    color: '#666',
    marginTop: 8,
  },
  errorContainer: {
    position: 'absolute',
    bottom: 20,
    left: 20,
    right: 20,
    backgroundColor: '#ff6b6b',
    padding: 10,
    borderRadius: 8,
  },
  errorText: {
    color: '#fff',
    textAlign: 'center',
  },
});
```

---

## SectionList for Grouped Data

Display data organized into sections with headers.

```jsx path=null start=null
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  SectionList,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';

const GroupedList = () => {
  const [sections, setSections] = useState([]);
  const [collapsedSections, setCollapsedSections] = useState({});

  useEffect(() => {
    // Generate sample grouped data
    const generateSections = () => {
      return [
        {
          id: 'recent',
          title: 'Recent Items',
          data: [
            { id: '1', name: 'Document 1', date: '2023-12-01' },
            { id: '2', name: 'Document 2', date: '2023-12-02' },
            { id: '3', name: 'Document 3', date: '2023-12-03' },
          ],
        },
        {
          id: 'thisWeek',
          title: 'This Week',
          data: [
            { id: '4', name: 'Document 4', date: '2023-11-28' },
            { id: '5', name: 'Document 5', date: '2023-11-29' },
          ],
        },
        {
          id: 'lastWeek',
          title: 'Last Week',
          data: [
            { id: '6', name: 'Document 6', date: '2023-11-20' },
            { id: '7', name: 'Document 7', date: '2023-11-22' },
            { id: '8', name: 'Document 8', date: '2023-11-25' },
          ],
        },
        {
          id: 'older',
          title: 'Older',
          data: [
            { id: '9', name: 'Document 9', date: '2023-11-10' },
            { id: '10', name: 'Document 10', date: '2023-11-05' },
          ],
        },
      ];
    };

    setSections(generateSections());
  }, []);

  const toggleSection = (sectionId) => {
    setCollapsedSections(prev => ({
      ...prev,
      [sectionId]: !prev[sectionId],
    }));
  };

  const renderItem = ({ item, index, section }) => {
    const isCollapsed = collapsedSections[section.id];
    
    if (isCollapsed) {
      return null; // Don't render items for collapsed sections
    }

    return (
      <TouchableOpacity 
        style={styles.item}
        onPress={() => console.log('Item pressed:', item.name)}
      >
        <View style={styles.itemContent}>
          <Text style={styles.itemName}>{item.name}</Text>
          <Text style={styles.itemDate}>{item.date}</Text>
        </View>
        <View style={styles.itemArrow}>
          <Text style={styles.arrowText}>›</Text>
        </View>
      </TouchableOpacity>
    );
  };

  const renderSectionHeader = ({ section }) => {
    const isCollapsed = collapsedSections[section.id];
    const itemCount = section.data.length;
    
    return (
      <TouchableOpacity
        style={styles.sectionHeader}
        onPress={() => toggleSection(section.id)}
        activeOpacity={0.7}
      >
        <View style={styles.sectionHeaderContent}>
          <Text style={styles.sectionTitle}>{section.title}</Text>
          <Text style={styles.sectionCount}>({itemCount})</Text>
        </View>
        <Text style={[
          styles.collapseIcon,
          isCollapsed && styles.collapseIconCollapsed
        ]}>
          ▼
        </Text>
      </TouchableOpacity>
    );
  };

  const renderSectionFooter = ({ section }) => {
    const isCollapsed = collapsedSections[section.id];
    
    if (isCollapsed || section.data.length === 0) {
      return null;
    }

    return <View style={styles.sectionFooter} />;
  };

  const keyExtractor = (item, index) => `${item.id}-${index}`;

  // Filter sections to hide items from collapsed sections
  const processedSections = sections.map(section => ({
    ...section,
    data: collapsedSections[section.id] ? [] : section.data,
  }));

  return (
    <View style={styles.container}>
      <SectionList
        sections={processedSections}
        renderItem={renderItem}
        renderSectionHeader={renderSectionHeader}
        renderSectionFooter={renderSectionFooter}
        keyExtractor={keyExtractor}
        stickySectionHeadersEnabled={true}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContainer}
        ItemSeparatorComponent={() => <View style={styles.separator} />}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  listContainer: {
    paddingBottom: 20,
  },
  sectionHeader: {
    backgroundColor: '#e8e8e8',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  sectionHeaderContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  sectionCount: {
    fontSize: 14,
    color: '#666',
    marginLeft: 8,
  },
  collapseIcon: {
    fontSize: 12,
    color: '#666',
    transform: [{ rotate: '0deg' }],
  },
  collapseIconCollapsed: {
    transform: [{ rotate: '-90deg' }],
  },
  item: {
    backgroundColor: '#fff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  itemContent: {
    flex: 1,
  },
  itemName: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  itemDate: {
    fontSize: 14,
    color: '#666',
  },
  itemArrow: {
    paddingLeft: 12,
  },
  arrowText: {
    fontSize: 18,
    color: '#999',
  },
  separator: {
    height: StyleSheet.hairlineWidth,
    backgroundColor: '#e0e0e0',
    marginLeft: 16,
  },
  sectionFooter: {
    height: 10,
    backgroundColor: '#f5f5f5',
  },
});
```

---

## Search and Filter

Implement real-time search and filtering functionality.

```jsx path=null start=null
import React, { useState, useMemo, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  TextInput,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';

const SearchableList = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');
  
  // Sample data
  const rawData = [
    { id: '1', name: 'Apple iPhone 14', category: 'electronics', price: 999 },
    { id: '2', name: 'Samsung Galaxy S23', category: 'electronics', price: 899 },
    { id: '3', name: 'Nike Air Max', category: 'shoes', price: 120 },
    { id: '4', name: 'Adidas Ultraboost', category: 'shoes', price: 180 },
    { id: '5', name: 'MacBook Pro', category: 'electronics', price: 2499 },
    { id: '6', name: 'Converse Chuck Taylor', category: 'shoes', price: 65 },
    { id: '7', name: 'iPad Air', category: 'electronics', price: 599 },
    { id: '8', name: 'Puma Running Shoes', category: 'shoes', price: 90 },
  ];

  const categories = ['all', 'electronics', 'shoes'];

  // Memoized filtered data
  const filteredData = useMemo(() => {
    let filtered = rawData;

    // Filter by category
    if (selectedCategory !== 'all') {
      filtered = filtered.filter(item => item.category === selectedCategory);
    }

    // Filter by search query
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(item =>
        item.name.toLowerCase().includes(query) ||
        item.category.toLowerCase().includes(query)
      );
    }

    return filtered;
  }, [searchQuery, selectedCategory]);

  const renderItem = useCallback(({ item }) => (
    <TouchableOpacity style={styles.item}>
      <View style={styles.itemContent}>
        <Text style={styles.itemName}>{item.name}</Text>
        <Text style={styles.itemCategory}>{item.category}</Text>
      </View>
      <Text style={styles.itemPrice}>${item.price}</Text>
    </TouchableOpacity>
  ), []);

  const renderCategoryButton = (category) => {
    const isSelected = selectedCategory === category;
    return (
      <TouchableOpacity
        key={category}
        style={[styles.categoryButton, isSelected && styles.selectedCategory]}
        onPress={() => setSelectedCategory(category)}
      >
        <Text style={[
          styles.categoryButtonText,
          isSelected && styles.selectedCategoryText
        ]}>
          {category.charAt(0).toUpperCase() + category.slice(1)}
        </Text>
      </TouchableOpacity>
    );
  };

  const keyExtractor = useCallback((item) => item.id, []);

  return (
    <View style={styles.container}>
      {/* Search Input */}
      <View style={styles.searchContainer}>
        <TextInput
          style={styles.searchInput}
          value={searchQuery}
          onChangeText={setSearchQuery}
          placeholder="Search products..."
          placeholderTextColor="#999"
          clearButtonMode="while-editing" // iOS
        />
      </View>

      {/* Category Filters */}
      <View style={styles.categoriesContainer}>
        {categories.map(renderCategoryButton)}
      </View>

      {/* Results Count */}
      <View style={styles.resultsContainer}>
        <Text style={styles.resultsText}>
          {filteredData.length} result{filteredData.length !== 1 ? 's' : ''}
        </Text>
      </View>

      {/* List */}
      <FlatList
        data={filteredData}
        renderItem={renderItem}
        keyExtractor={keyExtractor}
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
        ListEmptyComponent={() => (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>
              {searchQuery ? 'No results found' : 'No items available'}
            </Text>
            {searchQuery && (
              <Text style={styles.emptySubtext}>
                Try adjusting your search or filters
              </Text>
            )}
          </View>
        )}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  searchContainer: {
    padding: 16,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  searchInput: {
    height: 40,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 20,
    paddingHorizontal: 16,
    fontSize: 16,
    backgroundColor: '#f9f9f9',
  },
  categoriesContainer: {
    flexDirection: 'row',
    padding: 16,
    backgroundColor: '#fff',
  },
  categoryButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#f0f0f0',
    marginRight: 8,
  },
  selectedCategory: {
    backgroundColor: '#007AFF',
  },
  categoryButtonText: {
    fontSize: 14,
    color: '#666',
  },
  selectedCategoryText: {
    color: '#fff',
  },
  resultsContainer: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  resultsText: {
    fontSize: 14,
    color: '#666',
  },
  listContainer: {
    padding: 16,
  },
  item: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  itemContent: {
    flex: 1,
  },
  itemName: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  itemCategory: {
    fontSize: 14,
    color: '#666',
    textTransform: 'capitalize',
  },
  itemPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#007AFF',
  },
  emptyContainer: {
    padding: 40,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: '#999',
    textAlign: 'center',
  },
  emptySubtext: {
    fontSize: 14,
    color: '#ccc',
    textAlign: 'center',
    marginTop: 8,
  },
});
```

---

## 💡 Key Takeaways

1. **FlatList** is essential for performant list rendering
2. **Performance optimization** is crucial for large datasets
3. **Infinite scrolling** improves user experience for large datasets
4. **SectionList** organizes data into logical groups
5. **Search and filtering** should be real-time and responsive
6. **Memoization** prevents unnecessary re-renders
7. **Viewability tracking** optimizes resource usage

---

## 🔗 Related Notes
- [[3.Core React Native Components]] - Basic list components
- [[14.Performance Optimization]] - Advanced list performance
- [[10.Data Fetching]] - Loading data for lists

## 📚 Next Steps
1. Practice building different list layouts
2. Implement infinite scrolling with real APIs
3. Add advanced filtering and sorting
4. Move on to [[8.Images and Media]]

---
*Tags: #react-native #lists #flatlist #sectionlist #data #stage-2 #performance*
