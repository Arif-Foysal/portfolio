---
title: "Expo vs React Native CLI"
description: "Comprehensive comparison between Expo and React Native CLI approaches for React Native development"
navigation:
  icon: i-lucide-house
---

# Expo vs React Native CLI

#react-native #expo #cli #development #stage-6

> Comprehensive comparison between Expo and React Native CLI approaches for React Native development

## 🔗 Navigation
← [[16.TypeScript in React Native]] | → [[Debugging and Testing]]

---

## Overview and Key Differences

Understanding the fundamental differences between Expo and React Native CLI workflows.

### What is Expo?
Expo is a platform and set of tools that simplifies React Native development by providing:
- **Managed workflow** with pre-configured build tools
- **Over-the-air updates** without app store releases
- **Built-in APIs** for common mobile features
- **Expo Go app** for easy testing on devices
- **Cloud build services** (EAS Build)

### What is React Native CLI?
React Native CLI (also called "bare" React Native) provides:
- **Full control** over native code and project structure
- **Direct access** to iOS and Android project files
- **Custom native modules** and third-party integrations
- **Standard native development** workflow

### Quick Comparison Table

| Feature | Expo Managed | React Native CLI |
|---------|---------------|------------------|
| **Setup Time** | Minutes | Hours |
| **Native Code Access** | Limited | Full |
| **Custom Native Modules** | Expo SDK only | Any module |
| **Build Process** | Cloud-based (EAS) | Local/CI |
| **OTA Updates** | Built-in | Manual setup |
| **Bundle Size** | Larger (Expo SDK) | Smaller |
| **Development Speed** | Faster initial | Slower initial |
| **Platform APIs** | Expo APIs | Direct access |

---

## Expo Managed Workflow

Deep dive into Expo's managed workflow benefits and limitations.

### Setup and Configuration
```bash path=null start=null
# Install Expo CLI
npm install -g @expo/cli

# Create new Expo project
npx create-expo-app MyApp
cd MyApp

# Start development server
npx expo start

# Install Expo Go app on phone and scan QR code
```

### Expo Configuration
```json path=null start=null
// app.json
{
  "expo": {
    "name": "My App",
    "slug": "my-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "updates": {
      "fallbackToCacheTimeout": 0,
      "url": "https://u.expo.dev/[your-project-id]"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.example.myapp"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FFFFFF"
      },
      "package": "com.example.myapp"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-camera",
      "expo-location",
      [
        "expo-notifications",
        {
          "icon": "./local/assets/notification-icon.png",
          "color": "#ffffff"
        }
      ]
    ]
  }
}
```

### Expo SDK Features
```jsx path=null start=null
import { StatusBar } from 'expo-status-bar';
import { Camera } from 'expo-camera';
import * as Location from 'expo-location';
import * as Notifications from 'expo-notifications';
import * as ImagePicker from 'expo-image-picker';
import * as FileSystem from 'expo-file-system';
import * as SecureStore from 'expo-secure-store';

const ExpoFeatureExample = () => {
  const [location, setLocation] = useState(null);
  const [cameraRef, setCameraRef] = useState(null);

  // Location example
  const getLocation = async () => {
    const { status } = await Location.requestForegroundPermissionsAsync();
    if (status === 'granted') {
      const location = await Location.getCurrentPositionAsync({});
      setLocation(location);
    }
  };

  // Camera example
  const takePicture = async () => {
    if (cameraRef) {
      const photo = await cameraRef.takePictureAsync();
      console.log('Photo taken:', photo.uri);
    }
  };

  // Notifications example
  const scheduleNotification = async () => {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "You've got mail! 📬",
        body: 'Here is the notification body',
        data: { data: 'goes here' },
      },
      trigger: { seconds: 2 },
    });
  };

  // Image picker example
  const pickImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.All,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });

    if (!result.cancelled) {
      console.log('Image selected:', result.uri);
    }
  };

  // Secure storage example
  const storeSecureData = async (key, value) => {
    await SecureStore.setItemAsync(key, value);
  };

  const getSecureData = async (key) => {
    return await SecureStore.getItemAsync(key);
  };

  return (
    <View style={styles.container}>
      <StatusBar style="auto" />
      
      <Camera
        style={styles.camera}
        ref={ref => setCameraRef(ref)}
        type={Camera.Constants.Type.back}
      >
        <TouchableOpacity style={styles.cameraButton} onPress={takePicture}>
          <Text style={styles.buttonText}>Take Photo</Text>
        </TouchableOpacity>
      </Camera>

      <Button title="Get Location" onPress={getLocation} />
      <Button title="Schedule Notification" onPress={scheduleNotification} />
      <Button title="Pick Image" onPress={pickImage} />
      
      {location && (
        <Text>
          Lat: {location.coords.latitude}, Lng: {location.coords.longitude}
        </Text>
      )}
    </View>
  );
};
```

### Over-the-Air Updates
```jsx path=null start=null
import * as Updates from 'expo-updates';

const UpdatesExample = () => {
  const [updateAvailable, setUpdateAvailable] = useState(false);

  useEffect(() => {
    checkForUpdates();
  }, []);

  const checkForUpdates = async () => {
    try {
      const update = await Updates.checkForUpdateAsync();
      if (update.isAvailable) {
        setUpdateAvailable(true);
        await Updates.fetchUpdateAsync();
        // Show user prompt to restart
        Alert.alert(
          'Update Available',
          'A new version is available. Restart to apply?',
          [
            { text: 'Later', style: 'cancel' },
            { text: 'Restart', onPress: () => Updates.reloadAsync() },
          ]
        );
      }
    } catch (error) {
      console.log('Error checking for updates:', error);
    }
  };

  return (
    <View>
      {updateAvailable && (
        <TouchableOpacity 
          style={styles.updateBanner}
          onPress={() => Updates.reloadAsync()}
        >
          <Text style={styles.updateText}>Tap to apply update</Text>
        </TouchableOpacity>
      )}
      {/* Rest of your app */}
    </View>
  );
};
```

---

## React Native CLI (Bare Workflow)

Complete control over native code and build processes.

### Setup and Configuration
```bash path=null start=null
# Install React Native CLI
npm install -g react-native-cli

# Create new project
npx react-native init MyApp
cd MyApp

# iOS setup (macOS only)
cd ios && pod install && cd ..

# Start Metro bundler
npx react-native start

# Run on iOS (in another terminal)
npx react-native run-ios

# Run on Android
npx react-native run-android
```

### Project Structure
```bash path=null start=null
MyApp/
├── android/                 # Android native code
│   ├── app/
│   │   ├── src/main/
│   │   │   ├── java/
│   │   │   └── AndroidManifest.xml
│   │   └── build.gradle
│   └── build.gradle
├── ios/                     # iOS native code
│   ├── MyApp/
│   │   ├── Info.plist
│   │   └── AppDelegate.m
│   └── MyApp.xcodeproj/
├── src/                     # JavaScript code
├── package.json
└── metro.config.js
```

### Native Module Integration
```jsx path=null start=null
// Example: Using react-native-camera (requires native linking)
import { RNCamera } from 'react-native-camera';
import RNFS from 'react-native-fs';
import { check, request, PERMISSIONS, RESULTS } from 'react-native-permissions';

const NativeFeaturesExample = () => {
  const [hasPermission, setHasPermission] = useState(null);

  useEffect(() => {
    requestCameraPermission();
  }, []);

  const requestCameraPermission = async () => {
    const permission = Platform.OS === 'ios' 
      ? PERMISSIONS.IOS.CAMERA 
      : PERMISSIONS.ANDROID.CAMERA;
    
    const result = await request(permission);
    setHasPermission(result === RESULTS.GRANTED);
  };

  const takePicture = async (camera) => {
    const options = { quality: 0.5, base64: true };
    const data = await camera.takePictureAsync(options);
    
    // Save to device storage
    const path = `${RNFS.DocumentDirectoryPath}/photo_${Date.now()}.jpg`;
    await RNFS.writeFile(path, data.base64, 'base64');
    
    console.log('Photo saved to:', path);
  };

  if (hasPermission === null) return <Text>Requesting camera permission...</Text>;
  if (hasPermission === false) return <Text>No access to camera</Text>;

  return (
    <View style={styles.container}>
      <RNCamera
        ref={ref => setCameraRef(ref)}
        style={styles.preview}
        type={RNCamera.Constants.Type.back}
        flashMode={RNCamera.Constants.FlashMode.off}
        androidCameraPermissionOptions={{
          title: 'Permission to use camera',
          message: 'We need your permission to use your camera',
          buttonPositive: 'Ok',
          buttonNegative: 'Cancel',
        }}
      >
        {({ camera, status }) => {
          if (status !== 'READY') return <PendingView />;
          return (
            <View style={styles.captureContainer}>
              <TouchableOpacity
                onPress={() => takePicture(camera)}
                style={styles.capture}
              >
                <Text style={styles.captureText}>SNAP</Text>
              </TouchableOpacity>
            </View>
          );
        }}
      </RNCamera>
    </View>
  );
};
```

### Custom Native Module (Android)
```java path=null start=null
// android/app/src/main/java/com/myapp/CustomModule.java
package com.myapp;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.Callback;

public class CustomModule extends ReactContextBaseJavaModule {
    CustomModule(ReactApplicationContext context) {
        super(context);
    }

    @Override
    public String getName() {
        return "CustomModule";
    }

    @ReactMethod
    public void getDeviceInfo(Promise promise) {
        try {
            String deviceName = android.os.Build.MODEL;
            String deviceVersion = android.os.Build.VERSION.RELEASE;
            
            WritableMap result = Arguments.createMap();
            result.putString("deviceName", deviceName);
            result.putString("deviceVersion", deviceVersion);
            
            promise.resolve(result);
        } catch (Exception e) {
            promise.reject("ERROR", e);
        }
    }

    @ReactMethod
    public void showToast(String message) {
        Toast.makeText(getReactApplicationContext(), message, Toast.LENGTH_SHORT).show();
    }
}
```

### Using Custom Module
```jsx path=null start=null
import { NativeModules } from 'react-native';

const { CustomModule } = NativeModules;

const CustomModuleExample = () => {
  const [deviceInfo, setDeviceInfo] = useState(null);

  const getDeviceInfo = async () => {
    try {
      const info = await CustomModule.getDeviceInfo();
      setDeviceInfo(info);
    } catch (error) {
      console.error('Failed to get device info:', error);
    }
  };

  const showToast = () => {
    CustomModule.showToast('Hello from native code!');
  };

  return (
    <View style={styles.container}>
      <Button title="Get Device Info" onPress={getDeviceInfo} />
      <Button title="Show Toast" onPress={showToast} />
      
      {deviceInfo && (
        <View>
          <Text>Device: {deviceInfo.deviceName}</Text>
          <Text>Version: {deviceInfo.deviceVersion}</Text>
        </View>
      )}
    </View>
  );
};
```

---

## Migration and Hybrid Approaches

Moving between Expo and CLI, or using hybrid approaches.

### Ejecting from Expo (Deprecated)
```bash path=null start=null
# Note: expo eject is deprecated
# Use 'npx expo prebuild' for Expo Dev Client instead

# Generate native code
npx expo prebuild

# This creates ios/ and android/ directories while keeping Expo SDK
```

### Expo Dev Client (Recommended Hybrid)
```bash path=null start=null
# Install Expo Dev Client
npx expo install expo-dev-client

# Create development build
npx expo run:ios
npx expo run:android

# Or use EAS Build for cloud builds
eas build --platform ios --profile development
```

### Moving from CLI to Expo
```bash path=null start=null
# Install Expo CLI in existing React Native project
npm install @expo/cli

# Initialize Expo configuration
npx expo init --name MyApp

# Install Expo SDK
npx expo install

# Convert to use Expo modules
npx install-expo-modules
```

### Brownfield Integration
```jsx path=null start=null
// Integrating React Native into existing native apps

// iOS (AppDelegate.m)
// Add React Native view to existing iOS app
#import <React/RCTBridge.h>
#import <React/RCTBundleURLProvider.h>
#import <React/RCTRootView.h>

@implementation AppDelegate

- (void)showReactNativeScreen {
    NSURL *jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
    
    RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                                        moduleName:@"MyReactScreen"
                                                 initialProperties:@{}
                                                     launchOptions:nil];
    
    UIViewController *vc = [[UIViewController alloc] init];
    vc.view = rootView;
    [self.window.rootViewController presentViewController:vc animated:YES completion:nil];
}

@end
```

---

## Build and Deployment Comparison

Different approaches to building and deploying applications.

### Expo Build Process
```bash path=null start=null
# Install EAS CLI
npm install -g eas-cli

# Configure EAS
eas login
eas build:configure

# Build for different environments
eas build --platform ios --profile preview
eas build --platform android --profile production

# Submit to stores
eas submit --platform ios
eas submit --platform android
```

### EAS Build Configuration
```json path=null start=null
// eas.json
{
  "cli": {
    "version": ">= 2.0.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "resourceClass": "m1-medium"
      }
    },
    "preview": {
      "distribution": "internal",
      "ios": {
        "simulator": true
      }
    },
    "production": {
      "ios": {
        "resourceClass": "m1-medium"
      }
    }
  },
  "submit": {
    "production": {
      "ios": {
        "appleId": "your-apple-id@example.com",
        "ascAppId": "1234567890",
        "appleTeamId": "ABCD123456"
      },
      "android": {
        "serviceAccountKeyPath": "../path/to/api-key.json",
        "track": "internal"
      }
    }
  }
}
```

### React Native CLI Build Process
```bash path=null start=null
# iOS Release Build
cd ios
xcodebuild -workspace MyApp.xcworkspace \
           -scheme MyApp \
           -configuration Release \
           -destination 'generic/platform=iOS' \
           -archivePath MyApp.xcarchive \
           archive

# Android Release Build
cd android
./gradlew assembleRelease

# Generate signed APK
./gradlew assembleRelease \
  -PMYAPP_UPLOAD_STORE_FILE=my-upload-key.keystore \
  -PMYAPP_UPLOAD_KEY_ALIAS=my-key-alias \
  -PMYAPP_UPLOAD_STORE_PASSWORD=**** \
  -PMYAPP_UPLOAD_KEY_PASSWORD=****
```

---

## Performance Considerations

Understanding performance implications of each approach.

### Bundle Size Comparison
```jsx path=null start=null
// Expo app bundle includes entire SDK (~35MB base)
// CLI app includes only used modules (~15-25MB typical)

// Measuring bundle size
// For Expo
npx expo export --dump-assetmap

// For CLI
npx react-native bundle --platform android \
                       --dev false \
                       --entry-file index.js \
                       --bundle-output android.bundle \
                       --assets-dest /tmp

// Analyze with bundle visualizer
npm install --global react-native-bundle-visualizer
npx react-native-bundle-visualizer
```

### Startup Time Optimization
```jsx path=null start=null
// Expo optimization
import { AppLoading } from 'expo-app-loading';
import * as Font from 'expo-font';

const ExpoOptimizedApp = () => {
  const [isReady, setIsReady] = useState(false);

  const loadResourcesAsync = async () => {
    await Font.loadAsync({
      'Roboto': require('./assets/fonts/Roboto.ttf'),
    });
  };

  if (!isReady) {
    return (
      <AppLoading
        startAsync={loadResourcesAsync}
        onFinish={() => setIsReady(true)}
        onError={console.warn}
      />
    );
  }

  return <MainApp />;
};

// CLI optimization - lazy loading
const CLIOptimizedApp = () => {
  const [fontsLoaded, setFontsLoaded] = useState(false);

  useEffect(() => {
    // Load critical resources only
    loadCriticalResources().then(() => setFontsLoaded(true));
  }, []);

  if (!fontsLoaded) {
    return <SplashScreen />;
  }

  return <MainApp />;
};
```

---

## Decision Framework

Guidelines for choosing between Expo and React Native CLI.

### Choose Expo When:
- **Rapid prototyping** or MVP development
- **Limited native development** experience
- **Standard mobile features** are sufficient
- **Quick deployment** and OTA updates are important
- **Team size is small** or focused on JavaScript
- **Timeline is tight** for initial release

### Choose React Native CLI When:
- **Custom native functionality** is required
- **Third-party native libraries** are essential
- **Performance optimization** is critical
- **Complex native integrations** needed
- **Existing native apps** need React Native integration
- **Full control** over build process is required

### Evaluation Checklist
```markdown path=null start=null
## Project Requirements Analysis

### Functionality Requirements
- [ ] Camera/Photos
- [ ] Location services
- [ ] Push notifications
- [ ] Offline functionality
- [ ] Complex animations
- [ ] Custom native features
- [ ] Third-party SDKs

### Team Considerations
- [ ] Native development expertise (iOS/Android)
- [ ] JavaScript/React experience
- [ ] Team size and timeline
- [ ] Maintenance resources

### Business Requirements
- [ ] Time to market
- [ ] Budget constraints
- [ ] Update frequency needs
- [ ] Platform-specific features
- [ ] App store guidelines compliance
```

---

## 💡 Best Practices and Tips

1. **Start with Expo** for rapid development, then eject if needed
2. **Use Expo Dev Client** for hybrid approach benefits
3. **Consider bundle size** impact on user experience
4. **Plan for platform-specific** features early
5. **Evaluate third-party libraries** compatibility
6. **Set up proper CI/CD** for either approach
7. **Test on real devices** regardless of approach
8. **Consider maintenance** and update strategies
9. **Document architectural decisions** for team clarity
10. **Plan migration path** if switching approaches later

---

## 🔗 Related Notes
- [[React Native Learning Path]] - Choose your development approach
- [[12.Platform APIs]] - Native features in both approaches
- [[13.Popular React Native Libraries]] - Library compatibility considerations

## 📚 Next Steps
1. Evaluate your project requirements against both approaches
2. Set up development environment for chosen approach
3. Create a simple test project to compare workflows
4. Move on to [[Debugging and Testing]]

---
*Tags: #react-native #expo #cli #development #workflow #stage-6 #comparison #native-modules*
