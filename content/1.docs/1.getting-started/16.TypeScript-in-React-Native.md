---
title: "TypeScript in React Native"
description: "Setting up and using TypeScript for type-safe React Native development"
navigation:
  icon: i-lucide-house
---

# TypeScript in React Native

#react-native #typescript #type-safety #stage-5

> Setting up and using TypeScript for type-safe React Native development

## 🔗 Navigation
← [[15.Advanced Animations]] | → [[17.Expo vs React Native CLI]]

---

## Setup and Configuration

Setting up TypeScript in a React Native project for enhanced development experience.

### New Project Setup
```bash path=null start=null
# Create new project with TypeScript template
npx react-native init MyApp --template react-native-template-typescript

# Or with Expo
npx create-expo-app MyApp --template

# Add TypeScript to existing project
npm install -D typescript @types/react @types/react-native
```

### TypeScript Configuration
```json path=null start=null
// tsconfig.json
{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["es2017", "es2018", "es2019", "es2020"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-native"
  },
  "include": [
    "src/**/*",
    "index.js",
    "App.tsx"
  ],
  "exclude": [
    "node_modules",
    "babel.config.js",
    "metro.config.js",
    "jest.config.js"
  ]
}
```

---

## Basic Types and Interfaces

Fundamental TypeScript patterns for React Native components.

### Component Props and State
```tsx path=null start=null
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ViewStyle, TextStyle } from 'react-native';

// Interface for component props
interface UserProfileProps {
  userId: string;
  showEmail?: boolean;
  onUserLoad?: (user: User) => void;
  style?: ViewStyle;
}

// User data interface
interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  createdAt: Date;
  role: 'admin' | 'user' | 'moderator';
}

// API response interface
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
  errors?: string[];
}

const UserProfile: React.FC<UserProfileProps> = ({
  userId,
  showEmail = false,
  onUserLoad,
  style,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        const response = await fetch(`/api/users/${userId}`);
        const result: ApiResponse<User> = await response.json();
        
        if (result.success) {
          setUser(result.data);
          onUserLoad?.(result.data);
        } else {
          setError(result.message || 'Failed to load user');
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId, onUserLoad]);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text style={styles.error}>Error: {error}</Text>;
  if (!user) return <Text>User not found</Text>;

  return (
    <View style={[styles.container, style]}>
      <Text style={styles.name}>{user.name}</Text>
      {showEmail && <Text style={styles.email}>{user.email}</Text>}
      <Text style={styles.role}>Role: {user.role}</Text>
    </View>
  );
};

// Styled component interfaces
interface Styles {
  container: ViewStyle;
  name: TextStyle;
  email: TextStyle;
  role: TextStyle;
  error: TextStyle;
}

const styles = StyleSheet.create<Styles>({
  container: {
    padding: 16,
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
  },
  name: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  email: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  role: {
    fontSize: 12,
    textTransform: 'uppercase',
    color: '#999',
  },
  error: {
    color: 'red',
    textAlign: 'center',
  },
});
```

---

## Navigation Types

Type-safe navigation with React Navigation and TypeScript.

### Navigation Stack Types
```tsx path=null start=null
import { NavigatorScreenParams } from '@react-navigation/native';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { BottomTabScreenProps } from '@react-navigation/bottom-tabs';

// Root navigation types
export type RootStackParamList = {
  Onboarding: undefined;
  Auth: NavigatorScreenParams<AuthStackParamList>;
  Main: NavigatorScreenParams<MainTabParamList>;
  Profile: { userId: string };
  Settings: undefined;
  PostDetail: { postId: string; userId?: string };
};

// Auth stack types
export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
  ForgotPassword: { email?: string };
};

// Main tab navigation types
export type MainTabParamList = {
  Home: undefined;
  Search: { initialQuery?: string };
  Notifications: undefined;
  Profile: { userId?: string };
};

// Screen prop types
export type RootStackScreenProps<T extends keyof RootStackParamList> =
  NativeStackScreenProps<RootStackParamList, T>;

export type AuthStackScreenProps<T extends keyof AuthStackParamList> =
  NativeStackScreenProps<AuthStackParamList, T>;

export type MainTabScreenProps<T extends keyof MainTabParamList> =
  BottomTabScreenProps<MainTabParamList, T>;

// Usage in components
interface LoginScreenProps extends AuthStackScreenProps<'Login'> {}

const LoginScreen: React.FC<LoginScreenProps> = ({ navigation, route }) => {
  const handleLogin = () => {
    // Type-safe navigation
    navigation.navigate('Register');
    
    // Navigate to main app with parameters
    navigation.getParent()?.navigate('Main', {
      screen: 'Profile',
      params: { userId: 'current-user' },
    });
  };

  return (
    <View>
      {/* Login form */}
    </View>
  );
};

// Hook for type-safe navigation
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';

type NavigationProp = NativeStackNavigationProp<RootStackParamList>;

export const useAppNavigation = () => {
  return useNavigation<NavigationProp>();
};
```

---

## Custom Hooks with Types

Type-safe custom hooks for reusable logic.

### API Hooks
```tsx path=null start=null
import { useState, useEffect, useCallback } from 'react';

// Generic API response type
interface ApiState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

// Custom hook for API calls
export function useApi<T>(
  url: string,
  options?: RequestInit
): ApiState<T> & { refetch: () => Promise<void> } {
  const [state, setState] = useState<ApiState<T>>({
    data: null,
    loading: true,
    error: null,
  });

  const fetchData = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true }));
    
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data: T = await response.json();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState({
        data: null,
        loading: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }, [url, options]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    ...state,
    refetch: fetchData,
  };
}

// Form hook with validation
interface FormField<T> {
  value: T;
  error: string | null;
  touched: boolean;
}

interface FormState<T> {
  [K in keyof T]: FormField<T[K]>;
}

type ValidationRules<T> = {
  [K in keyof T]?: (value: T[K]) => string | null;
};

export function useForm<T extends Record<string, any>>(
  initialValues: T,
  validationRules: ValidationRules<T> = {}
) {
  const [formState, setFormState] = useState<FormState<T>>(() => {
    const state = {} as FormState<T>;
    Object.keys(initialValues).forEach(key => {
      state[key as keyof T] = {
        value: initialValues[key],
        error: null,
        touched: false,
      };
    });
    return state;
  });

  const setValue = useCallback(<K extends keyof T>(
    field: K,
    value: T[K]
  ) => {
    setFormState(prev => ({
      ...prev,
      [field]: {
        ...prev[field],
        value,
        error: validationRules[field] ? validationRules[field]!(value) : null,
        touched: true,
      },
    }));
  }, [validationRules]);

  const validate = useCallback(() => {
    const newState = { ...formState };
    let isValid = true;

    Object.keys(formState).forEach(key => {
      const field = key as keyof T;
      const rule = validationRules[field];
      if (rule) {
        const error = rule(formState[field].value);
        newState[field] = {
          ...newState[field],
          error,
          touched: true,
        };
        if (error) isValid = false;
      }
    });

    setFormState(newState);
    return isValid;
  }, [formState, validationRules]);

  const getValues = useCallback(() => {
    const values = {} as T;
    Object.keys(formState).forEach(key => {
      values[key as keyof T] = formState[key as keyof T].value;
    });
    return values;
  }, [formState]);

  return {
    formState,
    setValue,
    validate,
    getValues,
  };
}
```

---

## Context API with Types

Type-safe context for global state management.

### Authentication Context
```tsx path=null start=null
import React, { createContext, useContext, useReducer, ReactNode } from 'react';

// User and auth types
interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  role: 'user' | 'admin';
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
}

// Auth actions
type AuthAction =
  | { type: 'AUTH_START' }
  | { type: 'AUTH_SUCCESS'; payload: User }
  | { type: 'AUTH_FAILURE'; payload: string }
  | { type: 'LOGOUT' }
  | { type: 'CLEAR_ERROR' };

// Auth context type
interface AuthContextType {
  state: AuthState;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  register: (userData: RegisterData) => Promise<void>;
  clearError: () => void;
}

interface RegisterData {
  email: string;
  password: string;
  name: string;
}

// Initial state
const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  loading: false,
  error: null,
};

// Reducer
function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case 'AUTH_START':
      return { ...state, loading: true, error: null };
    case 'AUTH_SUCCESS':
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        loading: false,
        error: null,
      };
    case 'AUTH_FAILURE':
      return {
        ...state,
        user: null,
        isAuthenticated: false,
        loading: false,
        error: action.payload,
      };
    case 'LOGOUT':
      return {
        ...state,
        user: null,
        isAuthenticated: false,
        loading: false,
        error: null,
      };
    case 'CLEAR_ERROR':
      return { ...state, error: null };
    default:
      return state;
  }
}

// Create context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Provider component
interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = async (email: string, password: string): Promise<void> => {
    dispatch({ type: 'AUTH_START' });
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        throw new Error('Login failed');
      }

      const { user }: { user: User } = await response.json();
      dispatch({ type: 'AUTH_SUCCESS', payload: user });
    } catch (error) {
      dispatch({
        type: 'AUTH_FAILURE',
        payload: error instanceof Error ? error.message : 'Login failed',
      });
    }
  };

  const register = async (userData: RegisterData): Promise<void> => {
    dispatch({ type: 'AUTH_START' });
    
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData),
      });

      if (!response.ok) {
        throw new Error('Registration failed');
      }

      const { user }: { user: User } = await response.json();
      dispatch({ type: 'AUTH_SUCCESS', payload: user });
    } catch (error) {
      dispatch({
        type: 'AUTH_FAILURE',
        payload: error instanceof Error ? error.message : 'Registration failed',
      });
    }
  };

  const logout = (): void => {
    dispatch({ type: 'LOGOUT' });
  };

  const clearError = (): void => {
    dispatch({ type: 'CLEAR_ERROR' });
  };

  const value: AuthContextType = {
    state,
    login,
    logout,
    register,
    clearError,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Hook to use auth context
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

---

## Component Composition with Types

Advanced patterns for component composition and reusability.

### Generic Components
```tsx path=null start=null
import React from 'react';
import { FlatList, FlatListProps, Text, View } from 'react-native';

// Generic list component
interface ListItem {
  id: string | number;
}

interface GenericListProps<T extends ListItem> 
  extends Omit<FlatListProps<T>, 'data' | 'renderItem'> {
  data: T[];
  renderItem: (item: T, index: number) => React.ReactElement;
  emptyMessage?: string;
  loading?: boolean;
}

function GenericList<T extends ListItem>({
  data,
  renderItem,
  emptyMessage = 'No items found',
  loading = false,
  ...flatListProps
}: GenericListProps<T>) {
  if (loading) {
    return <Text>Loading...</Text>;
  }

  if (data.length === 0) {
    return <Text>{emptyMessage}</Text>;
  }

  return (
    <FlatList
      data={data}
      renderItem={({ item, index }) => renderItem(item, index)}
      keyExtractor={(item) => String(item.id)}
      {...flatListProps}
    />
  );
}

// Usage with specific types
interface Product extends ListItem {
  name: string;
  price: number;
  category: string;
}

const ProductList: React.FC<{ products: Product[] }> = ({ products }) => {
  return (
    <GenericList
      data={products}
      renderItem={(product, index) => (
        <View key={product.id}>
          <Text>{product.name}</Text>
          <Text>${product.price}</Text>
          <Text>{product.category}</Text>
        </View>
      )}
      emptyMessage="No products available"
    />
  );
};

// Higher-order component with types
interface WithLoadingProps {
  loading: boolean;
  error?: string | null;
}

function withLoading<P extends object>(
  Component: React.ComponentType<P>
): React.FC<P & WithLoadingProps> {
  return ({ loading, error, ...props }: WithLoadingProps & P) => {
    if (loading) {
      return <Text>Loading...</Text>;
    }

    if (error) {
      return <Text>Error: {error}</Text>;
    }

    return <Component {...(props as P)} />;
  };
}

// Usage
const ProductListWithLoading = withLoading(ProductList);

const App: React.FC = () => {
  const { data: products, loading, error } = useApi<Product[]>('/api/products');

  return (
    <ProductListWithLoading
      products={products || []}
      loading={loading}
      error={error}
    />
  );
};
```

---

## Third-Party Library Types

Working with popular libraries and their TypeScript definitions.

### AsyncStorage with Types
```tsx path=null start=null
import AsyncStorage from '@react-native-async-storage/async-storage';

// Storage utility with types
class TypedAsyncStorage {
  static async setItem<T>(key: string, value: T): Promise<void> {
    await AsyncStorage.setItem(key, JSON.stringify(value));
  }

  static async getItem<T>(key: string): Promise<T | null> {
    const item = await AsyncStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  }

  static async removeItem(key: string): Promise<void> {
    await AsyncStorage.removeItem(key);
  }

  static async multiSet<T>(keyValuePairs: [string, T][]): Promise<void> {
    const pairs = keyValuePairs.map(([key, value]) => [key, JSON.stringify(value)]);
    await AsyncStorage.multiSet(pairs as [string, string][]);
  }

  static async multiGet<T>(keys: string[]): Promise<Record<string, T | null>> {
    const results = await AsyncStorage.multiGet(keys);
    const data: Record<string, T | null> = {};
    
    results.forEach(([key, value]) => {
      data[key] = value ? JSON.parse(value) : null;
    });
    
    return data;
  }
}

// Usage
interface UserSettings {
  theme: 'light' | 'dark';
  notifications: boolean;
  language: string;
}

const saveUserSettings = async (settings: UserSettings) => {
  await TypedAsyncStorage.setItem('user_settings', settings);
};

const getUserSettings = async (): Promise<UserSettings | null> => {
  return await TypedAsyncStorage.getItem<UserSettings>('user_settings');
};
```

### React Native Reanimated Types
```tsx path=null start=null
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  SharedValue,
  AnimatedStyleProp,
  ViewStyle,
} from 'react-native-reanimated';

// Animated component with proper types
interface AnimatedBoxProps {
  children?: React.ReactNode;
  style?: AnimatedStyleProp<ViewStyle>;
}

const AnimatedBox: React.FC<AnimatedBoxProps> = ({ children, style }) => {
  const scale = useSharedValue(1);
  
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const handlePress = () => {
    scale.value = withSpring(scale.value === 1 ? 1.2 : 1);
  };

  return (
    <Animated.View style={[style, animatedStyle]} onTouchEnd={handlePress}>
      {children}
    </Animated.View>
  );
};

// Custom animation hook with types
interface UseSpringAnimationReturn {
  value: SharedValue<number>;
  animatedStyle: AnimatedStyleProp<ViewStyle>;
  animate: (toValue: number) => void;
}

const useSpringAnimation = (initialValue: number = 0): UseSpringAnimationReturn => {
  const value = useSharedValue(initialValue);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: value.value }],
  }));

  const animate = (toValue: number) => {
    value.value = withSpring(toValue);
  };

  return { value, animatedStyle, animate };
};
```

---

## Type Guards and Utilities

Utility types and type guards for better type safety.

### Type Guards
```tsx path=null start=null
// Type guard functions
export function isString(value: unknown): value is string {
  return typeof value === 'string';
}

export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value);
}

export function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

// API response type guard
export function isApiResponse<T>(
  response: unknown,
  dataValidator: (data: unknown) => data is T
): response is ApiResponse<T> {
  return (
    isObject(response) &&
    'success' in response &&
    typeof response.success === 'boolean' &&
    'data' in response &&
    dataValidator(response.data)
  );
}

// Usage
const validateUser = (data: unknown): data is User => {
  return (
    isObject(data) &&
    'id' in data &&
    'name' in data &&
    'email' in data &&
    isString(data.id) &&
    isString(data.name) &&
    isString(data.email)
  );
};

const handleApiResponse = (response: unknown) => {
  if (isApiResponse(response, validateUser)) {
    // response is now typed as ApiResponse<User>
    console.log(response.data.name);
  }
};

// Utility types
export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// Usage
interface CreateUserData extends Optional<User, 'id' | 'createdAt'> {
  password: string;
}

interface UserWithRequiredEmail extends RequiredFields<Partial<User>, 'email'> {}
```

---

## 💡 TypeScript Best Practices

1. **Enable strict mode** in tsconfig.json for maximum type safety
2. **Use interfaces over types** for object shapes when possible
3. **Create union types** for constrained string values
4. **Use generic types** for reusable components and hooks
5. **Implement type guards** for runtime type checking
6. **Type your navigation params** for type-safe routing
7. **Use utility types** like Partial, Required, Pick, and Omit
8. **Create custom hooks with proper types** for reusable logic
9. **Type your context providers** and consumers
10. **Use const assertions** for immutable data structures

---

## 🔗 Related Notes
- [[React Basics for React Native]] - React concepts with TypeScript
- [[5.React Navigation]] - Type-safe navigation setup
- [[9.Local State Management]] - Typed state management patterns

## 📚 Next Steps
1. Set up TypeScript in your React Native project
2. Create type-safe navigation stack
3. Implement typed custom hooks and context providers
4. Move on to [[17.Expo vs React Native CLI]]

---
*Tags: #react-native #typescript #type-safety #stage-5 #interfaces #generics #navigation-types*
