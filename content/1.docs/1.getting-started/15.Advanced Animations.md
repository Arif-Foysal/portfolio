---
title: "Advanced Animations"
description: "Advanced animation techniques using React Native Reanimated and other animation libraries"
navigation:
  icon: i-lucide-house
---

# Advanced Animations

#react-native #animations #reanimated #stage-5

> Advanced animation techniques using React Native Reanimated and other animation libraries

## 🔗 Navigation
← [[14.Performance Optimization]] | → [[16.TypeScript in React Native]]

---

## React Native Reanimated 3

The most powerful animation library for React Native, running animations on the UI thread.

### Setup and Basic Concepts
```bash path=null start=null
npm install react-native-reanimated
cd ios && pod install  # iOS only
```

```jsx path=null start=null
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  withDelay,
  withSequence,
  withRepeat,
  runOnJS,
  runOnUI,
} from 'react-native-reanimated';

const BasicReanimatedExample = () => {
  // Shared values run on UI thread
  const translateX = useSharedValue(0);
  const opacity = useSharedValue(1);
  const scale = useSharedValue(1);

  // Animated styles are computed on UI thread
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { scale: scale.value },
      ],
      opacity: opacity.value,
    };
  });

  const startAnimations = () => {
    // Spring animation
    translateX.value = withSpring(100, {
      damping: 15,
      stiffness: 150,
    });

    // Timing animation
    opacity.value = withTiming(0.5, {
      duration: 1000,
    });

    // Sequence of animations
    scale.value = withSequence(
      withTiming(1.5, { duration: 500 }),
      withTiming(1, { duration: 500 })
    );
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, animatedStyle]} />
      <Button title="Animate" onPress={startAnimations} />
    </View>
  );
};
```

---

## Gesture-Based Animations

Combine animations with gesture handling for interactive experiences.

### Pan Gesture Animations
```jsx path=null start=null
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withDecay,
  runOnJS,
} from 'react-native-reanimated';

const DraggableBox = () => {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const scale = useSharedValue(1);
  
  const startingPosition = useSharedValue({ x: 0, y: 0 });

  const panGesture = Gesture.Pan()
    .onBegin(() => {
      scale.value = withSpring(1.1);
      startingPosition.value = { x: translateX.value, y: translateY.value };
    })
    .onUpdate((event) => {
      translateX.value = startingPosition.value.x + event.translationX;
      translateY.value = startingPosition.value.y + event.translationY;
    })
    .onEnd((event) => {
      scale.value = withSpring(1);
      
      // Add momentum with decay
      translateX.value = withDecay({
        velocity: event.velocityX,
        clamp: [-200, 200],
      });
      
      translateY.value = withDecay({
        velocity: event.velocityY,
        clamp: [-400, 400],
      });
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
  }));

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={[styles.draggableBox, animatedStyle]} />
    </GestureDetector>
  );
};
```

### Swipe and Snap Animations
```jsx path=null start=null
const SwipeableCard = ({ onSwipe }) => {
  const translateX = useSharedValue(0);
  const rotation = useSharedValue(0);
  const opacity = useSharedValue(1);

  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      translateX.value = event.translationX;
      
      // Add rotation based on translation
      rotation.value = event.translationX * 0.1;
      
      // Fade out as card moves away
      opacity.value = Math.max(0.3, 1 - Math.abs(event.translationX) / 300);
    })
    .onEnd((event) => {
      const shouldSwipe = Math.abs(event.translationX) > 100;
      
      if (shouldSwipe) {
        // Swipe away
        const direction = event.translationX > 0 ? 1 : -1;
        translateX.value = withTiming(direction * 400, {
          duration: 300,
        }, () => {
          // Callback when animation completes
          runOnJS(onSwipe)(direction);
        });
        
        rotation.value = withTiming(direction * 30);
        opacity.value = withTiming(0);
      } else {
        // Snap back to center
        translateX.value = withSpring(0);
        rotation.value = withSpring(0);
        opacity.value = withSpring(1);
      }
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { rotateZ: `${rotation.value}deg` },
    ],
    opacity: opacity.value,
  }));

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={[styles.card, animatedStyle]}>
        <Text style={styles.cardText}>Swipe me!</Text>
      </Animated.View>
    </GestureDetector>
  );
};
```

---

## Layout Animations

Animate layout changes smoothly with entering/exiting animations.

### Layout Transition Animations
```jsx path=null start=null
import Animated, {
  Layout,
  FadeIn,
  FadeOut,
  SlideInRight,
  SlideOutLeft,
  ZoomIn,
  ZoomOut,
  FlipInEasyX,
} from 'react-native-reanimated';

const AnimatedList = ({ items, onRemoveItem }) => {
  return (
    <ScrollView style={styles.container}>
      {items.map((item, index) => (
        <Animated.View
          key={item.id}
          entering={SlideInRight.delay(index * 100)}
          exiting={SlideOutLeft}
          layout={Layout.springify()}
          style={styles.listItem}
        >
          <Text style={styles.itemText}>{item.title}</Text>
          <Pressable
            onPress={() => onRemoveItem(item.id)}
            style={styles.removeButton}
          >
            <Text>Remove</Text>
          </Pressable>
        </Animated.View>
      ))}
    </ScrollView>
  );
};

// Custom entering animation
const CustomEntering = () => {
  'worklet';
  const animations = {
    opacity: withTiming(1, { duration: 1000 }),
    transform: [
      { scale: withSpring(1, { damping: 15 }) },
      { rotateY: withTiming('0deg', { duration: 800 }) },
    ],
  };
  
  const initialValues = {
    opacity: 0,
    transform: [
      { scale: 0.5 },
      { rotateY: '90deg' },
    ],
  };
  
  return {
    animations,
    initialValues,
  };
};
```

### Modal and Overlay Animations
```jsx path=null start=null
const AnimatedModal = ({ visible, onClose, children }) => {
  const backdropOpacity = useSharedValue(0);
  const modalScale = useSharedValue(0.5);
  const modalTranslateY = useSharedValue(50);

  useEffect(() => {
    if (visible) {
      // Show modal
      backdropOpacity.value = withTiming(0.5, { duration: 300 });
      modalScale.value = withSpring(1, {
        damping: 15,
        stiffness: 150,
      });
      modalTranslateY.value = withSpring(0);
    } else {
      // Hide modal
      backdropOpacity.value = withTiming(0, { duration: 200 });
      modalScale.value = withTiming(0.5, { duration: 200 });
      modalTranslateY.value = withTiming(50, { duration: 200 });
    }
  }, [visible]);

  const backdropStyle = useAnimatedStyle(() => ({
    opacity: backdropOpacity.value,
  }));

  const modalStyle = useAnimatedStyle(() => ({
    transform: [
      { scale: modalScale.value },
      { translateY: modalTranslateY.value },
    ],
  }));

  if (!visible && backdropOpacity.value === 0) {
    return null;
  }

  return (
    <View style={StyleSheet.absoluteFillObject}>
      <Animated.View style={[styles.backdrop, backdropStyle]}>
        <Pressable style={StyleSheet.absoluteFillObject} onPress={onClose} />
      </Animated.View>
      
      <View style={styles.modalContainer}>
        <Animated.View style={[styles.modal, modalStyle]}>
          {children}
        </Animated.View>
      </View>
    </View>
  );
};
```

---

## Complex Animation Sequences

Create sophisticated animation sequences for enhanced user experience.

### Staggered Animations
```jsx path=null start=null
const StaggeredList = ({ items }) => {
  const animatedValues = items.map(() => ({
    opacity: useSharedValue(0),
    translateY: useSharedValue(30),
    scale: useSharedValue(0.8),
  }));

  const startStaggeredAnimation = () => {
    animatedValues.forEach((values, index) => {
      const delay = index * 100;
      
      values.opacity.value = withDelay(delay, withTiming(1, { duration: 400 }));
      values.translateY.value = withDelay(delay, withSpring(0));
      values.scale.value = withDelay(delay, withSpring(1));
    });
  };

  useEffect(() => {
    startStaggeredAnimation();
  }, [items]);

  return (
    <View style={styles.container}>
      {items.map((item, index) => {
        const animatedStyle = useAnimatedStyle(() => ({
          opacity: animatedValues[index].opacity.value,
          transform: [
            { translateY: animatedValues[index].translateY.value },
            { scale: animatedValues[index].scale.value },
          ],
        }));

        return (
          <Animated.View key={item.id} style={[styles.staggeredItem, animatedStyle]}>
            <Text>{item.title}</Text>
          </Animated.View>
        );
      })}
    </View>
  );
};
```

### Page Transition Animations
```jsx path=null start=null
const PageTransition = ({ currentPage, nextPage, progress }) => {
  const currentPageStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: progress.value * -300 },
        { scale: 1 - progress.value * 0.1 },
      ],
      opacity: 1 - progress.value,
    };
  });

  const nextPageStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: (1 - progress.value) * 300 },
        { scale: 0.9 + progress.value * 0.1 },
      ],
      opacity: progress.value,
    };
  });

  return (
    <View style={StyleSheet.absoluteFillObject}>
      <Animated.View style={[styles.page, currentPageStyle]}>
        {currentPage}
      </Animated.View>
      
      <Animated.View style={[styles.page, nextPageStyle]}>
        {nextPage}
      </Animated.View>
    </View>
  );
};

// Usage with gesture
const SwipeablePages = ({ pages }) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const progress = useSharedValue(0);

  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      const newProgress = Math.max(0, Math.min(1, -event.translationX / 300));
      progress.value = newProgress;
    })
    .onEnd((event) => {
      const shouldChangePage = -event.translationX > 150;
      
      if (shouldChangePage && currentIndex < pages.length - 1) {
        progress.value = withTiming(1, { duration: 300 }, () => {
          runOnJS(() => {
            setCurrentIndex(prev => prev + 1);
            progress.value = 0;
          })();
        });
      } else {
        progress.value = withSpring(0);
      }
    });

  return (
    <GestureDetector gesture={panGesture}>
      <View style={styles.container}>
        <PageTransition
          currentPage={pages[currentIndex]}
          nextPage={pages[currentIndex + 1]}
          progress={progress}
        />
      </View>
    </GestureDetector>
  );
};
```

---

## Shared Element Transitions

Create smooth transitions between screens with shared elements.

### Basic Shared Element Transition
```jsx path=null start=null
import { SharedValue, useSharedValue, withTiming } from 'react-native-reanimated';

// Shared element provider
const SharedElementProvider = ({ children }) => {
  const sharedElements = useRef(new Map()).current;

  const registerElement = (id, value) => {
    sharedElements.set(id, value);
  };

  const getSharedElement = (id) => {
    return sharedElements.get(id);
  };

  return (
    <SharedElementContext.Provider value={{ registerElement, getSharedElement }}>
      {children}
    </SharedElementContext.Provider>
  );
};

// Shared element component
const SharedElement = ({ id, children, style }) => {
  const { registerElement, getSharedElement } = useContext(SharedElementContext);
  const animatedStyle = useSharedValue(style);

  useEffect(() => {
    registerElement(id, {
      animatedStyle,
      element: children,
    });
  }, [id]);

  const computedStyle = useAnimatedStyle(() => {
    return animatedStyle.value;
  });

  return (
    <Animated.View style={[style, computedStyle]}>
      {children}
    </Animated.View>
  );
};

// Screen with shared element
const ListScreen = ({ onItemPress }) => {
  return (
    <FlatList
      data={items}
      renderItem={({ item }) => (
        <Pressable onPress={() => onItemPress(item)}>
          <SharedElement id={`item-${item.id}`}>
            <Image source={{ uri: item.image }} style={styles.listImage} />
          </SharedElement>
        </Pressable>
      )}
    />
  );
};

const DetailScreen = ({ item, onBack }) => {
  const { getSharedElement } = useContext(SharedElementContext);
  
  useEffect(() => {
    const sharedEl = getSharedElement(`item-${item.id}`);
    if (sharedEl) {
      // Animate to detail view position
      sharedEl.animatedStyle.value = withTiming({
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        height: 300,
      });
    }
  }, []);

  return (
    <View style={styles.detailContainer}>
      <SharedElement id={`item-${item.id}`}>
        <Image source={{ uri: item.image }} style={styles.detailImage} />
      </SharedElement>
      <Text style={styles.detailTitle}>{item.title}</Text>
    </View>
  );
};
```

---

## Animation Performance Optimization

Ensure smooth animations with performance best practices.

### Running Animations on UI Thread
```jsx path=null start=null
import { runOnUI, runOnJS } from 'react-native-reanimated';

const PerformantAnimations = () => {
  const progress = useSharedValue(0);
  
  // Worklet functions run on UI thread
  const updateProgress = useCallback((value) => {
    'worklet';
    progress.value = withTiming(value);
  }, []);

  // Heavy computation on UI thread
  const complexCalculation = useCallback(() => {
    'worklet';
    const result = progress.value * Math.PI * 2;
    return Math.sin(result) * 100;
  }, []);

  const animatedStyle = useAnimatedStyle(() => {
    const translateX = complexCalculation();
    
    return {
      transform: [{ translateX }],
    };
  });

  // Callback to JS thread when needed
  const onAnimationComplete = useCallback((finished) => {
    'worklet';
    if (finished) {
      runOnJS(handleAnimationComplete)();
    }
  }, []);

  const handleAnimationComplete = () => {
    console.log('Animation completed on JS thread');
  };

  return (
    <Animated.View style={[styles.box, animatedStyle]} />
  );
};
```

### Memory-Efficient Animations
```jsx path=null start=null
// Reuse animation objects
const animationConfigs = {
  spring: { damping: 15, stiffness: 150 },
  timing: { duration: 300 },
  bounce: { damping: 8, stiffness: 100, restDisplacementThreshold: 0.01 },
};

const MemoryEfficientAnimations = ({ items }) => {
  // Reuse shared values for similar animations
  const translateValues = useMemo(
    () => items.map(() => useSharedValue(0)),
    [items.length]
  );

  const animateItems = useCallback(() => {
    translateValues.forEach((value, index) => {
      value.value = withDelay(
        index * 50,
        withSpring(100, animationConfigs.spring)
      );
    });
  }, [translateValues]);

  // Cleanup when component unmounts
  useEffect(() => {
    return () => {
      translateValues.forEach(value => {
        value.value = 0;
      });
    };
  }, []);

  return (
    <View>
      {items.map((item, index) => {
        const animatedStyle = useAnimatedStyle(() => ({
          transform: [{ translateX: translateValues[index].value }],
        }));

        return (
          <Animated.View key={item.id} style={[styles.item, animatedStyle]}>
            <Text>{item.title}</Text>
          </Animated.View>
        );
      })}
    </View>
  );
};
```

---

## Custom Animation Hooks

Create reusable animation logic with custom hooks.

### Bounce Animation Hook
```jsx path=null start=null
const useBounceAnimation = (trigger) => {
  const scale = useSharedValue(1);

  useEffect(() => {
    if (trigger) {
      scale.value = withSequence(
        withTiming(0.8, { duration: 100 }),
        withSpring(1.2, { damping: 8 }),
        withSpring(1, { damping: 12 })
      );
    }
  }, [trigger]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  return animatedStyle;
};

// Usage
const BounceButton = ({ onPress, children }) => {
  const [pressed, setPressed] = useState(false);
  const bounceStyle = useBounceAnimation(pressed);

  const handlePress = () => {
    setPressed(true);
    setTimeout(() => setPressed(false), 50);
    onPress();
  };

  return (
    <Pressable onPress={handlePress}>
      <Animated.View style={[styles.button, bounceStyle]}>
        {children}
      </Animated.View>
    </Pressable>
  );
};
```

### Fade Animation Hook
```jsx path=null start=null
const useFadeAnimation = (visible, duration = 300) => {
  const opacity = useSharedValue(visible ? 1 : 0);

  useEffect(() => {
    opacity.value = withTiming(visible ? 1 : 0, { duration });
  }, [visible, duration]);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
  }));

  return animatedStyle;
};

// Scale animation hook
const useScaleAnimation = (active) => {
  const scale = useSharedValue(active ? 1 : 0);

  useEffect(() => {
    scale.value = withSpring(active ? 1 : 0);
  }, [active]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  return animatedStyle;
};
```

---

## 💡 Animation Best Practices

1. **Use react-native-reanimated** for complex animations that need 60fps
2. **Run animations on UI thread** whenever possible with worklets
3. **Minimize bridge communication** during animations
4. **Reuse animation objects** to reduce memory usage
5. **Use appropriate easing curves** for natural motion
6. **Test animations on low-end devices** to ensure performance
7. **Combine gestures with animations** for interactive experiences
8. **Use layout animations** for smooth list updates
9. **Cache animated values** when possible
10. **Profile animations** to identify performance bottlenecks

---

## 🔗 Related Notes
- [[14.Performance Optimization]] - Animation performance tips
- [[6.Handling User Input]] - Combining gestures with animations
- [[13.Popular React Native Libraries]] - Animation libraries

## 📚 Next Steps
1. Practice creating complex gesture-based animations
2. Implement shared element transitions between screens
3. Create custom animation hooks for reusable effects
4. Move on to [[16.TypeScript in React Native]]

---
*Tags: #react-native #animations #reanimated #gestures #stage-5 #performance #ui-thread*
