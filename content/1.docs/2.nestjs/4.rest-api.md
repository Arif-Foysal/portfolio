---
title: REST API Best Practices
description: Designing maintainable and predictable REST endpoints with NestJS.
navigation:
  icon: i-lucide-compass
---

## Resource Driven Routing

Stick to nouns for resources and HTTP verbs for actions: `/users`, `/users/:id`, `/auth/login`, `/posts/:postId/comments`. Keep routes lowercase and kebab case.

Group related routes in dedicated controllers per module so each controller stays focused on a resource boundary.

Use route parameters for resource identifiers and query parameters for filtering, pagination, and sorting.

## Controllers and HTTP Responses

Controllers should return data, not manually write to the response object, unless you need streaming or file downloads. Nest will set `200 OK` by default, but you can override status codes with decorators:

```ts
@Post()
@HttpCode(HttpStatus.CREATED)
create(@Body() dto: CreateUserDto) {
  return this.usersService.create(dto);
}
```

Respond with DTOs that hide internal fields (password hashes, tokens) and keep property names consistent across endpoints.

## Validation and Transformation

Apply global pipes for validation and transformation to guarantee that handlers receive sanitized input.

```ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,
    transform: true,
    transformOptions: { enableImplicitConversion: true },
  }),
);
```

Use custom pipes (like `ParseIntPipe`) to convert and validate individual parameters.

## Exception Handling

Throw `HttpException` or specialized subclasses to produce meaningful error responses. Add a global filter for consistent error payloads:

```ts
@Catch(HttpException)
export class HttpErrorFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const status = exception.getStatus();
    const body = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: ctx.getRequest<Request>().url,
      message: exception.message,
    };
    response.status(status).json(body);
  }
}
```

Register the filter globally via `app.useGlobalFilters(new HttpErrorFilter())` or at the controller level.

## Interceptors for Cross Cutting Concerns

Interceptors can log, cache, or transform responses.

```ts
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    const req = context.switchToHttp().getRequest<Request>();
    const start = Date.now();
    return next.handle().pipe(
      tap(() => {
        const duration = Date.now() - start;
        this.logger.log(`${req.method} ${req.url} ${duration}ms`);
      }),
    );
  }
}
```

Bind them globally with `app.useGlobalInterceptors(new LoggingInterceptor())` or locally via `@UseInterceptors`.

## Versioning Strategies

Nest supports URL, header, and media type versioning out of the box:

```ts
const app = await NestFactory.create(AppModule);
app.enableVersioning({ type: VersioningType.URI });
```

Version only the controllers that need it using `@Controller({ path: 'users', version: '2' })` so you can evolve the API without breaking existing clients.

## Consistent Pagination and Filtering

Define a standard DTO for pagination parameters (page, limit, cursor) and reuse it. Return metadata such as `total`, `page`, and `pageSize` so clients can render navigation controls.

For filtering, prefer query parameters like `/users?role=admin&isActive=true` and document supported filters explicitly.

## Observability and Documentation

- Add request IDs via middleware and include them in logs to trace flows end to end.
- Use `SwaggerModule` to expose OpenAPI documentation:

```ts
const config = new DocumentBuilder()
  .setTitle('Awesome API')
  .setVersion('1.0')
  .addBearerAuth()
  .build();
const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('docs', app, document);
```

Keep the documentation updated by reusing DTOs and decorators so clients always know how to call your API.

## Idempotency and Safety

For operations that might be retried (like payment processing), support idempotency keys via headers or request bodies. Ensure `PUT` replaces resources completely, while `PATCH` handles partial updates and performs validation on supplied fields only.

A disciplined approach to routing, validation, and error handling keeps your REST API intuitive and resilient.

