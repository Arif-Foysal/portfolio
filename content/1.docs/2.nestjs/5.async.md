---
title: Async Operations and External Communication
description: Calling external services, handling middleware, interceptors, and pipes in NestJS.
navigation:
  icon: i-lucide-zap
---

## HttpModule Essentials

Nest wraps Axios via `@nestjs/axios` to provide a DI friendly HTTP client.

```bash
npm install @nestjs/axios axios
```

```ts
@Module({
  imports: [
    HttpModule.register({
      timeout: 5000,
      maxRedirects: 5,
    }),
  ],
  providers: [ExternalApiService],
  exports: [ExternalApiService],
})
export class ExternalApiModule {}
```

Inject `HttpService` and use RxJS or `lastValueFrom` for promises:

```ts
@Injectable()
export class ExternalApiService {
  constructor(private readonly http: HttpService) {}

  async fetchWeather(city: string) {
    const response = await lastValueFrom(
      this.http.get(`https://api.example.com/weather`, {
        params: { city },
      }),
    );
    return response.data;
  }
}
```

Set per request overrides using `firstValueFrom(this.http.get(url, { timeout: 2000 }))` when needed.

## Retrying and Circuit Breaking

RxJS operators make retries and fallbacks straightforward:

```ts
return this.http.get(url).pipe(
  retry({ count: 2, delay: 250 }),
  catchError((error) => {
    this.logger.error('External API failed', error);
    return throwError(() => new ServiceUnavailableException());
  }),
);
```

For more advanced patterns, integrate libraries like `opossum` or use message queues to decouple requests.

## Middleware Pipeline

Middleware runs before guards, pipes, and interceptors. Use it for logging, request IDs, or parsing custom headers.

```ts
@Injectable()
export class RequestIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    req['requestId'] = randomUUID();
    res.setHeader('x-request-id', req['requestId']);
    next();
  }
}
```

Apply middleware in the module class:

```ts
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(RequestIdMiddleware).forRoutes('*');
  }
}
```

## Interceptors for Response Shaping

Interceptors can bind once and affect every request.

```ts
@Injectable()
export class TransformInterceptor<T> implements NestInterceptor<T, ResponseEnvelope<T>> {
  intercept(context: ExecutionContext, next: CallHandler<T>): Observable<ResponseEnvelope<T>> {
    return next.handle().pipe(map((data) => ({ data, success: true })));
  }
}
```

Use them for logging, caching, metrics, or wrapping responses in a consistent envelope.

## Using Pipes

Pipes transform and validate data before it reaches your route handler.

- Built in pipes: `ValidationPipe`, `ParseIntPipe`, `ParseBoolPipe`, `ParseArrayPipe`.
- Custom pipes: implement `PipeTransform` to coerce or sanitize values.

```ts
@Injectable()
export class TrimPipe implements PipeTransform<string, string> {
  transform(value: string) {
    return value.trim();
  }
}
```

Apply pipes at the parameter, route, controller, or global level:

```ts
@Get(':id')
findOne(
  @Param('id', ParseIntPipe) id: number,
  @Query('search', new TrimPipe()) search?: string,
) {
  return this.usersService.findOne(id, search);
}
```

## Task Queues and Background Work

For work that should not block HTTP responses, use queues (Bull, RabbitMQ) or scheduled jobs.

```bash
npm install @nestjs/bull bull ioredis
```

```ts
@Module({
  imports: [BullModule.forRoot({ redis: { host: 'localhost', port: 6379 } })],
})
export class JobsModule {}
```

Define processors with `@Processor('emails')` and produce jobs from services. This keeps external API retries resilient and prevents request timeouts.

## WebSockets and Streaming

`@nestjs/websockets` lets you push updates over WebSocket gateways. For server sent events, use `@Sse()` decorators and streams returned from RxJS observables.

Choose the protocol that matches the latency and delivery guarantees your feature requires.

By combining middleware, interceptors, pipes, and background workers, you can handle asynchronous workflows while keeping controllers simple.

