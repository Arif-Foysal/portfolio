---
title: Configuration and Environment
description: Managing environment variables and application configuration in NestJS.
navigation:
  icon: i-lucide-settings
---

## ConfigModule Basics

`@nestjs/config` centralizes environment variables, supports schema validation, and enables per environment overrides.

```bash
npm install @nestjs/config
```

```ts
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: ['.env.local', '.env'],
      cache: true,
    }),
  ],
})
export class AppModule {}
```

`isGlobal: true` means you do not have to import the module repeatedly. The array in `envFilePath` lets you layer environment specific files (development overrides first, then defaults).

## Environment Files

Keep secrets and environment specific settings outside source control. Common variables include database URLs, API keys, JWT secrets, and feature flags.

```
DATABASE_URL=postgres://postgres:password@localhost:5432/app
JWT_SECRET=super-secret
HTTP_TIMEOUT=5000
```

Load different files in CI (for example `.env.test`) to isolate environments.

## Validating Configuration

Validate configuration early to fail fast when variables are missing or malformed.

```bash
npm install joi
```

```ts
ConfigModule.forRoot({
  validationSchema: Joi.object({
    DATABASE_URL: Joi.string().uri().required(),
    JWT_SECRET: Joi.string().min(16).required(),
    HTTP_TIMEOUT: Joi.number().default(5000),
  }),
});
```

You can also use `class-transformer` and `class-validator` by supplying a `validate` function if you prefer a typed class approach.

## Accessing Config Values

Inject `ConfigService` wherever you need configuration.

```ts
@Injectable()
export class DatabaseConfig {
  constructor(private readonly config: ConfigService) {}

  get uri() {
    return this.config.getOrThrow<string>('DATABASE_URL');
  }
}
```

Use helper methods:

- `get(key, { infer: true })` to cast primitives automatically.
- `getOrThrow` to enforce presence at call time.
- `get<number>('HTTP_TIMEOUT', 5000)` to supply a fallback.

## Dynamic Configuration

Leverage namespaces for complex apps.

```ts
export default registerAs('database', () => ({
  uri: process.env.DATABASE_URL,
  maxConnections: parseInt(process.env.DB_POOL ?? '10', 10),
}));
```

Import the factory in the module and read via `configService.get('database.uri')` to keep related settings grouped.

## Environment Specific Modules

Conditionally load modules based on environment variables:

```ts
const imports = [];
if (process.env.ENABLE_METRICS === 'true') {
  imports.push(MetricsModule);
}

@Module({ imports })
export class AppModule {}
```

Couple this with feature flags so you can toggle integrations without redeploying.

## Secrets Management

For production deployments, prefer managed secret stores (AWS Secrets Manager, HashiCorp Vault, GCP Secret Manager). Fetch secrets during bootstrap and populate the configuration provider, or mount them as environment variables through your orchestrator.

Never commit secrets to source control and rotate them regularly.

## Sharing Configuration Across Services

Wrap configuration access in typed services so the rest of the application depends on clear contracts rather than raw strings.

```ts
@Injectable()
export class ApiConfig {
  constructor(private readonly config: ConfigService) {}

  get weatherUrl() {
    return this.config.getOrThrow<string>('WEATHER_API_URL');
  }

  get timeout() {
    return this.config.get<number>('HTTP_TIMEOUT', 5000);
  }
}
```

Providing dedicated config services simplifies testingâ€”you can override them with mock implementations in your unit tests.

By centralizing configuration, validating it early, and separating environment specific concerns, you keep deployments predictable and safe.

