---
title: Working with Data
description: Persisting and validating data using TypeORM or Prisma in NestJS.
navigation:
  icon: i-lucide-database
---

## Picking an ORM

Two popular paths cover most NestJS projects:

- **TypeORM**: decorator based entities, supports Active Record and Data Mapper, integrates tightly with Nest through `@nestjs/typeorm`.
- **Prisma**: schema first, generates a type safe client, shines for fast development and complex queries.

Pick whichever aligns with your team experience and project requirements. Many teams even layer repositories on top so switching later stays manageable.

## TypeORM in NestJS

Install packages for your database driver:

```bash
npm install @nestjs/typeorm typeorm pg
```

Configure the root module:

```ts
@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      url: process.env.DATABASE_URL,
      autoLoadEntities: true,
      synchronize: false,
    }),
  ],
})
export class AppModule {}
```

`autoLoadEntities` saves you from manually listing entities, but you can switch it off for tighter control. Always disable `synchronize` in production and use migrations instead.

### Feature Modules and Repositories

```ts
@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}
```

Inject repositories inside services:

```ts
@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User) private readonly repo: Repository<User>,
  ) {}

  async create(dto: CreateUserDto) {
    const entity = this.repo.create(dto);
    return this.repo.save(entity);
  }

  findOne(id: number) {
    return this.repo.findOne({ where: { id } });
  }
}
```

Repositories expose helpers for pagination, relations, transactions, and query builders.

### Entities

```ts
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  email: string;

  @Column()
  passwordHash: string;

  @Column({ default: true })
  isActive: boolean;
}
```

Map relations with `@OneToMany`, `@ManyToOne`, and supply `eager` or `lazy` loading depending on your needs.

### Migrations

- Use the TypeORM CLI or `typeorm migration:create` to generate SQL.
- Keep migration files committed so deployments stay reproducible.
- Run migrations in CI/CD before starting the application.

## Prisma in NestJS

Install and initialize Prisma:

```bash
npm install prisma @prisma/client
npx prisma init
```

Define your schema in `prisma/schema.prisma`:

```prisma
model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
}
```

Generate the client and run migrations:

```bash
npx prisma migrate dev
npx prisma generate
```

Create a shared `PrismaService` that extends `PrismaClient` and handles graceful shutdown:

```ts
@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

Provide it via a `DatabaseModule` and inject wherever needed.

## CRUD Patterns

Controllers should delegate to services that encapsulate persistence logic.

```ts
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() dto: CreateUserDto) {
    return this.usersService.create(dto);
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.usersService.findOne(id);
  }
}
```

Keep database specifics inside services or repositories so controllers remain unaware of Prisma versus TypeORM choices.

## Data Transfer Objects (DTOs)

DTOs define the contract for incoming and outgoing data. Decorate them with `class-validator` to enforce constraints.

```ts
import { IsEmail, IsString, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8)
  password: string;
}
```

Install supporting packages:

```bash
npm install class-validator class-transformer
```

## Validation Pipeline

Enable validation globally in `main.ts`:

```ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
  }),
);
```

- `whitelist` strips unknown properties.
- `forbidNonWhitelisted` throws when unexpected properties are present.
- `transform` converts payloads into DTO instances and handles primitive conversion when paired with `class-transformer` decorators like `@Type(() => Number)`.

Use DTOs for query parameters as well to keep validation consistent across the API.

## Testing the Data Layer

- Run unit tests with mocked repositories to isolate business logic.
- Use end to end tests against a disposable database (Docker, Testcontainers, or SQLite in memory).
- Seed predictable fixtures in migrations or factory functions so tests stay deterministic.

Treat the data layer as an implementation detail; by keeping boundaries clean you can swap or upgrade your persistence strategy with minimal disruption.

