---
title: Authentication and Authorization
description: Implementing JWT auth, guards, and role based access control in NestJS.
navigation:
  icon: i-lucide-shield
---

## Authentication Overview

Most production APIs need session management and authorization rules. A common stack in NestJS uses Passport with a local strategy for login and a JWT strategy for protected routes.

1. A user submits credentials to `/auth/login`.
2. The local strategy validates the user and password.
3. `AuthService` issues a signed JWT containing the user identifier and claims.
4. Guards verify the token on subsequent requests and make the payload available via `@Request()` or `@CurrentUser()` helpers.

Install the core dependencies:

```bash
npm install @nestjs/passport passport @nestjs/jwt passport-jwt bcrypt
```

## AuthModule Setup

Use `@nestjs/config` to keep secrets out of code when possible.

```ts
@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        secret: config.get<string>('JWT_SECRET'),
        signOptions: { expiresIn: '1h' },
      }),
    }),
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy, RolesGuard],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}
```

`PassportModule` wires Passport's lifecycle into Nest and `JwtModule` exposes `JwtService` for signing and verifying tokens.

## Local Strategy (Credential Validation)

```ts
@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string) {
    const user = await this.authService.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}
```

The strategy delegates to `AuthService`. Return value is attached to `req.user` for downstream guards or controllers.

## JWT Strategy (Protected Routes)

```ts
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(config: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: config.get<string>('JWT_SECRET'),
    });
  }

  async validate(payload: { sub: number; email: string; roles?: string[] }) {
    return { userId: payload.sub, email: payload.email, roles: payload.roles ?? [] };
  }
}
```

Returning a value from `validate` makes it available through `@Request()` or a custom decorator.

## AuthService Responsibilities

```ts
@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
  ) {}

  async validateUser(email: string, plainPassword: string) {
    const user = await this.usersService.findOneByEmail(email);
    if (!user) {
      return null;
    }
    const matches = await bcrypt.compare(plainPassword, user.passwordHash);
    return matches ? user : null;
  }

  async login(user: UserEntity) {
    const payload = { sub: user.id, email: user.email, roles: user.roles };
    return {
      accessToken: await this.jwtService.signAsync(payload),
      user,
    };
  }

  async signup(dto: SignupDto) {
    const passwordHash = await bcrypt.hash(dto.password, 10);
    const user = await this.usersService.create({ ...dto, passwordHash });
    return this.login(user);
  }
}
```

`login` can also issue refresh tokens or set cookies depending on your transport layer.

## Guards and Decorators

Protect routes by binding guards at the controller or route level.

```ts
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @UseGuards(AuthGuard('local'))
  @Post('login')
  async login(@Request() req) {
    return this.authService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@CurrentUser() user: CurrentUser) {
    return user;
  }
}
```

`JwtAuthGuard` typically extends `AuthGuard('jwt')` and adds convenience decorators such as `@CurrentUser()` to access the validated payload.

Mark public routes using metadata if you want a global guard that skips specific endpoints:

```ts
export const Public = () => SetMetadata('isPublic', true);
```

## Role Based Authorization

Leverage metadata plus a custom guard to enforce role checks.

```ts
export const Roles = (...roles: string[]) => SetMetadata('roles', roles);

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const required = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);
    if (!required) {
      return true;
    }
    const { user } = context.switchToHttp().getRequest();
    return required.some((role) => user?.roles?.includes(role));
  }
}
```

Apply it alongside the JWT guard:

```ts
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('admin')
@Get('admin')
findAdminData() {
  return 'secret';
}
```

## Advanced Considerations

- **Refresh tokens**: Store hashed refresh tokens in the database and rotate them on every use.
- **Token revocation**: Track token versions in the user table so you can invalidate old tokens server side.
- **Session cookies**: For browser based apps you can return the JWT in an `HttpOnly` cookie instead of the response body.
- **Testing**: Unit test guards by mocking the execution context, and run e2e tests that hit login endpoints to assert full flows.

Combine guards, decorators, and Passport strategies to create a layered security model that stays easy to maintain.

