---
title: NestJS Fundamentals
description: Core NestJS concepts you will use in every project.
navigation:
  icon: i-lucide-layers
tags:
  - Nest
---

## Why NestJS?

NestJS is a Node.js framework built on TypeScript that embraces object oriented, functional, and reactive programming ideas. It ships with structure by default so teams stay productive on large code bases.

- TypeScript first: Nest compiles to JavaScript while giving you strong typing, autocompletion, and safer refactors.
- Dependency injection everywhere: Classes declare their dependencies instead of creating them manually, which keeps modules decoupled and testable.
- Familiar tooling: Under the hood Nest uses Express or Fastify, so existing middleware or libraries can be reused.

A minimal bootstrap looks like this:

```ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```

## Nest CLI Essentials

The Nest CLI generates boilerplate so you can focus on features.

```bash
npm i -g @nestjs/cli
nest new awesome-api
```

Inside a project you can scaffold resources:

```bash
nest generate module users
nest generate controller users --no-spec
nest generate service users
```

The CLI follows `nest g <type> <name>` and keeps file naming consistent across the code base.

## Default Project Layout

After `nest new` you will see:

```
src/
  app.controller.ts
  app.service.ts
  app.module.ts
  main.ts
```

- `main.ts` bootstraps the Nest application.
- `app.module.ts` wires modules together.
- `app.controller.ts` handles incoming HTTP requests.
- `app.service.ts` hosts reusable business logic.

As the project grows, split features into dedicated folders under `src/`.

## Modules by Feature

Modules organize code by feature and declare their dependencies.

```ts
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

Key metadata:

- `imports`: other modules this module depends on.
- `controllers`: classes that handle HTTP or messaging transport.
- `providers`: services, repositories, factories, and other injectables.
- `exports`: providers made available to importing modules.

Register feature modules inside `AppModule` or another aggregation module.

## Dependency Injection Primer

Providers are classes decorated with `@Injectable()` so Nest can build and inject them.

```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  private users = new Map<number, User>();

  findAll(limit?: number) {
    const list = Array.from(this.users.values());
    return limit ? list.slice(0, limit) : list;
  }

  findOne(id: number) {
    return this.users.get(id);
  }
}
```

Use constructor injection in consumers:

```ts
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll(@Query('limit') limit?: number) {
    return this.usersService.findAll(limit ? Number(limit) : undefined);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(Number(id));
  }
}
```

Nest resolves dependencies by type. For interfaces or tokens, provide explicit bindings:

```ts
const CACHE_TOKEN = 'CACHE_TOKEN';

@Module({
  providers: [{ provide: CACHE_TOKEN, useClass: MemoryCacheService }],
})
export class CacheModule {}
```

## Controllers in Action

Controllers map incoming routes to handler methods using decorators.

```ts
import { Controller, Get, Post, Body, Param, Query } from '@nestjs/common';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() dto: CreateUserDto) {
    return this.usersService.create(dto);
  }
}
```

Incoming parameters are handled with decorators like `@Param()`, `@Query()`, and `@Body()`. Return values become JSON responses by default, so avoid injecting `@Res()` unless you need low level flexibility.

## Service Patterns

Services encapsulate reusable business logic, integrate with data sources, and coordinate cross cutting concerns.

```ts
@Injectable()
export class UsersService {
  private readonly users = new Map<number, User>();

  constructor(private readonly notifications: NotificationsService) {}

  async create(dto: CreateUserDto) {
    const id = this.users.size + 1;
    const user = { id, ...dto };
    this.users.set(id, user);
    await this.notifications.sendWelcome(user.email);
    return user;
  }
}
```

Guidelines:

- Keep controllers thin; push business rules into services.
- Export services from modules when other modules need them.
- Write unit tests using `Test.createTestingModule` and mocked dependencies.

## Putting It Together

A typical feature module has:

1. A controller that translates HTTP requests into method calls.
2. A service that applies business rules and orchestrates dependencies.
3. DTOs and entities that describe the data flowing through the module.

With these fundamentals in place you can confidently build out more advanced NestJS features.

